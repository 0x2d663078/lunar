#!/bin/sh

# Name:         lunar (Lockdown UNIX Analyse Report)
# Version:      1.4.6
# Release:      1
# License:      Open Source
# Group:        System
# Source:       N/A
# URL:          http://lateralblast.com.au/
# Distribution: Solaris
# Vendor:       UNIX
# Packager:     Richard Spindler <richard@lateralblast.com.au>
# Description:  Audit script based on various benchmarks
#               Addition improvements added
#               Writen in bourne shell so it can be run on different releases
#               Need to add trap and ntp support

# Changes:      0.0.0 Thursday, 25 October 2012  9:40:54 AM EST
#               Initial version
#               0.0.1 Thursday,  1 November 2012  2:28:41 PM EST
#               Added initial audit code
#               0.0.2 Fri  2 Nov 2012 13:24:54 EST
#               Created subroutines for updating files and parameters
#               0.0.3 Thursday,  8 November 2012  9:35:19 PM EST
#               Added restore code
#               0.0.4 Saturday, 10 November 2012 11:37:22 AM EST
#               Added kernel accounting
#               1.0.0 Monday, 12 November 2012 10:45:27 AM EST
#               Initial Github Commit
#               1.0.1 Monday, 12 November 2012  9:52:17 PM EST
#               Formating fixes
#               1.0.2 Monday, 12 November 2012 10:03:54 PM EST
#               Additional cleanup
#               1.0.3 Thu 15 Nov 2012 02:37:31 EST
#               Initial Solaris 11 support
#               1.0.4 Fri 16 Nov 2012 10:57:17 EST
#               Updated Solaris 11 support, Initial re-commit to new repository
#               1.0.5 Sat 17 Nov 2012 09:55:07 EST
#               Added echo services
#               1.0.6 Monday, 19 November 2012  8:13:20 AM EST
#               Solaris 10 and 11 support mostly done - some minor additions could be made
#               1.0.7 Monday, 19 November 2012 11:02:05 AM EST
#               Added initial support for Solaris versions less than 10
#               1.0.8 Thursday, 20 December 2012  2:46:32 PM EST
#               Fixed problem with inetadm command
#               1.0.9 Thursday, 20 December 2012  3:47:52 PM EST
#               Added -A and -L switches and moved filesystem searches to it
#               1.1.0 Thu 20 Dec 2012 17:01:52 EST
#               Cleaned up formating
#               1.1.1 Fri Dec 21 21:43:39 EST 2012
#               Initial Solaris 9 testing completed
#               1.1.2 Sat Dec 22 08:13:17 EST 2012
#               Fixed bugs with parameter value checking
#               1.1.3 Sat Dec 22 08:27:53 EST 2012
#               Fixed bug with home directory check
#               1.1.4 Sat Dec 22 08:50:38 EST 2012
#               Fixed bug with inetd code
#               1.1.5 Sat Dec 22 08:54:05 EST 2012
#               Fixed Solaris 9 update version detection
#               1.1.6 Sat Dec 22 16:45:16 EST 2012
#               Updated documentation
#               1.1.7 Thu Feb 14 20:46:31 EST 2013
#               Initial Linux support
#               1.1.8 Fri Feb 15 18:40:48 EST 2013
#               Linux xinetd and chkconfig support added
#               1.1.9 Sat Feb 16 12:01:05 EST 2013
#               Added sysctl audit for Linux
#               1.2.0 Sat Feb 16 14:09:03 EST 2013
#               Added ftpd logging checking for Linux
#               1.2.1 Sat Feb 16 14:22:58 EST 2013
#               Updated file update to support tabs
#               1.2.2 Sat Feb 16 22:30:05 EST 2013
#               Added pam options for Linux
#               1.2.3 Sun Feb 17 02:17:04 EST 2013
#               Added code for sendmail greeting
#               1.2.4 Sun 17 Feb 2013 08:27:32 EST
#               Added code for vsftpd banner
#               1.2.5 Sun Feb 17 19:55:54 EST 2013
#               Added securetty check for Linux
#               1.2.6 Sun 17 Feb 2013 20:40:27 EST
#               Added auditd config
#               1.2.7 Mon Feb 18 03:11:37 EST 2013
#               Added warning banners
#               1.2.8 Mon Feb 18 04:42:08 EST 2013
#               Added X11 warning messages
#               1.2.9 Mon Feb 18 09:41:55 EST 2013
#               Added Linux core dumps and rhosts for PAM
#               1.3.0 Mon Feb 18 13:42:24 EST 2013
#               Added gdm.conf audit
#               1.3.1 Mon Feb 18 14:38:04 EST 2013
#               Added Linux nodev audit
#               1.3.2 Mon Feb 18 15:08:26 EST 2013
#               Added Linux FDI audit
#               1.3.3 Mon Feb 18 17:53:30 EST 2013
#               Added X11 nolisten
#               1.3.4 Mon Feb 18 20:30:30 EST 2013
#               Improved file octal derivation on Solaris
#               1.3.5 Tue Feb 19 12:47:55 EST 2013
#               Added file verification for Linux
#               1.3.6 Tue Feb 19 14:48:33 EST 2013
#               Added password strength testing on Linux
#               1.3.7 Tue Feb 19 15:09:05 EST 2013
#               Added Cipher directive to SSH config
#               1.3.8 Tue Feb 19 15:37:52 EST 2013
#               Added logrotate configuration
#               1.3.9 Tue Feb 19 15:52:20 EST 2013
#               Added module loading and mounting to auditd
#               1.4.0 Tue Feb 19 17:03:17 EST 2013
#               Added modprobe.conf check
#               1.4.1 Tue Feb 19 17:25:39 EST 2013
#               Added sendmail local-only mode check
#               1.4.2 Tue Feb 19 17:32:12 EST 2013
#               Added code to check NTP running as ntp user
#               1.4.3 Tue Feb 19 21:01:02 EST 2013
#               Added selective function to run individual tests
#               1.4.4 Tue Feb 19 21:34:30 EST 2013
#               Added selinux
#               1.4.5 Tue Feb 19 21:46:55 EST 2013
#               Added yum config check
#               1.4.6 Tue Feb 19 22:59:12 EST 2013
#               Added lockout for failed password attempts

# No warrantry is implied or given with this script
# It is based on numerous security guidelines
# As with any system changes, the script should be vetted and
# changed to suit the environment in which it is being used

# To do:
#
# - nosuid,noexec for Linux
# - Disable user mounted removable filesystems for Linux
# - Disable USB devices for Linux
# - Fix at/cron allow/deny
# - Grub password
# - Restrict NFS client requests to privileged ports Linux
# - Block login of system accounts
# - Limit access to root

# Solaris Release Information
#  1/06 U1
#  6/06 U2
# 11/06 U3
#  8/07 U4
#  5/08 U5
# 10/08 U6
#  5/09 U7
# 10/09 U8
#  9/10 U9
#  8/11 U10

# audit_mode = 1 : Audit Mode
# audit_mode = 0 : Lockdown Mode
# audit_mode = 2 : Restore Mode

args=$@
score=0
pkg_company="LTRL"
pkg_suffix="lunar"
base_dir="/opt/$pkg_company$pkg_suffix"
date_suffix=`date +%d_%m_%Y_%H_%M_%S`
work_dir="$base_dir/$date_suffix"
temp_dir="$base_dir/tmp"
temp_file="$temp_dir/temp_file"
reboot=0
total=0

# This is the company name that will go into the securit message
# Change it as required

company_name="Lateral Blast Pty Ltd"

# If given a -h or no valid switch print usage information

print_usage () {
  echo ""
  echo "Usage: $0 [-a|c|l|h|V] [-u]"
  echo "-a: Run in audit mode (no changes made to system)"
  echo "-A: Run in audit mode (no changes made to system)"
  echo "    [includes filesystem checks which take some time]"
  echo "-s: Run in selective mode (only run tests you want to)"
  echo "-S: List functions available to selective mode"
  echo "-l: Run in lockdown mode (changes made to system)"
  echo "-L: Run in lockdown mode (changes made to system)"
  echo "    [includes filesystem checks which take some time]"
  echo "-d: Show changes previously made to system"
  echo "-p: Show previously versions of file"
  echo "-u: Undo lockdown (changes made to system)"
  echo "-h: Display usage"
  echo "-V: Display version"
  echo ""
  echo "Examples:"
  echo ""
  echo "Display previous backups:"
  echo ""
  echo "$0 -b"
  echo "Previous backups:"
  echo "21_12_2012_19_45_05  21_12_2012_20_35_54  21_12_2012_21_57_25  22_12_2012_07_37_44"
  echo ""
  echo "Restore from previous backup:"
  echo ""
  echo "$0 -u 21_12_2012_19_45_05"
  echo ""
  echo "Only run shell based tests:"
  echo ""
  echo "$0 -s audit_shell_services"
  echo ""
  exit
}

# Get OS release information

check_os_release () {
  os_name=`uname`
  if [ "$os_name" = "Linux" ]; then
    if [ -f "/etc/redhat-release" ]; then
      os_version=`cat /etc/redhat-release | awk '{print $3}' |cut -f1 -d'.'`
      os_update=`cat /etc/redhat-release | awk '{print $3}' |cut -f2 -d'.'`
      os_vendor=`cat /etc/redhat-release | awk '{print $1}'`
    fi
  fi
  if [ "$os_name" = "SunOS" ]; then
    os_vendor="Oracle Solaris"
    os_version=`uname -r |cut -f2 -d"."`
    if [ "$os_version" = "11" ]; then
      os_update=`cat /etc/release |grep Solaris |awk '{print $3}' |cut -f2 -d'.'`
    fi
    if [ "$os_version" = "10" ]; then
      os_update=`cat /etc/release |grep Solaris |awk '{print $5}' |cut -f2 -d'_' |sed 's/[A-z]//g'`
    fi
    if [ "$os_version" = "9" ]; then
      os_update=`cat /etc/release |grep Solaris |awk '{print $4}' |cut -f2 -d'_' |sed 's/[A-z]//g'`
    fi
  fi
  if [ "$os_name" != "Linux" ] && [ "$os_name" != "SunOS" ]; then
    echo "OS not supported"
    exit
  fi
  os_platform=`uname -p`
  echo "Platform:  $os_vendor $os_name $os_version Update $os_update on $os_platform"
}

# Do some environment checks
# Create base and temporary directory

check_environment () {
  check_os_release
  if [ ! -d "$base_dir" ]; then
    mkdir -p $base_dir
    chmod 700 $base_dir
    chown root:root $base_dir
  fi
  if [ ! -d "$temp_dir" ]; then
    mkdir -p $temp_dir
  fi
}

# Print previous changes

print_previous () {
  if [ -d "$base_dir" ]; then
    find $base_dir -type f -print -exec cat -n {} \;
  fi
}

# Do a diff between previous file (saved) and existing file

print_changes () {
  for saved_file in `find $base_dir -type f -print`; do
    check_file=`echo $saved_file |cut -f 5- -d"/"`
    top_dir=`echo $saved_file |cut -f 1-4 -d"/"`
    echo "Directory: $top_dir"
    log_test=`echo "$check_file" |grep "log$"`
    if [ `expr "$log_test" : "[A-z]"` = 1 ]; then
      echo "Original system parameters:"
      cat $saved_file |sed "s/,/ /g"
    else
      echo "Changes to /$check_file:"
      diff $saved_file /$check_file
    fi
  done
}

# Audit command output values
#
# This routine takes three values
#
# command_name    = The name of the command to run
# parameter_name  = The parameter to be checked
# correct_value   = The value we expect to be returned
#
# Depending on the command_name sent an appropriate check_command and set_command are set
# If the current_value is not the correct_value then it is fixed if run in lockdown mode
# A copy of the value is stored in a log file, which can be restored

audit_command_value () {
  command_name=$1
  parameter_name=$2
  correct_value=$3
  service_name=$4
  total=`expr $total + 1`
  if [ "$audit_mode" = 2 ]; then
    restore_file="$restore_dir/$command_name.log"
    if [ -f "$restore_file" ]; then
      parameter_name=`cat $restore_file |grep '$parameter_name' |cut -f1 -d','`
      correct_value=`cat $restore_file |grep '$parameter_name' |cut -f2 -d','`
      if [ `expr "$parameter_name" : "[A-z]"` = 1 ]; then
        echo "Returning $parameter_name to $correct_value"
        if [ "$command_name" = "routeadm" ]; then
          if [ "$correct_value" = "disabled" ]; then
            set_command="routeadm -d"
          else
            set_command="routeadm -e"
          fi
          $set_command $parameter_name
        else
          $set_command $parameter_name $correct_value
          if [ `expr "$parameter_name" : "tcp_trace"` = 9 ]; then
            svcadm refresh svc:/network/inetd
          fi
        fi
      fi
    fi
  else
    if [ "$parameter_name" = "tcp_wrappers" ]; then
      echo "Checking:  Service $service_name has \"$parameter_name\" set to \"$correct_value\""
    else
      echo "Checking:  Output of $command_name \"$parameter_name\" is \"$correct_value\""
    fi
  fi
  if [ "$command_name" = "inetadm" ]; then
    check_command="inetadm -l $service_name"
    set_command="inetadm -M"
    current_value=`$check_command |grep "$parameter_name" |awk '{print $2}' |cut -f2 -d'='`
  fi
  if [ "$command_name" = "routeadm" ]; then
    check_command="routeadm -p $parameter_name"
    current_value=`$check_command |awk '{print $3}' |cut -f2 -d'='`
  fi
  log_file="$work_dir/$command_name.log"
  if [ "$current_value" != "$correct_value" ]; then
    if [ "$audit_mode" = 1 ]; then
      score=`expr $score - 1`
      echo "Warning:   Parameter \"$parameter_name\" not set to \"$correct_value\" [$score]"
    else
      if [ "$audit_mode" = 0 ]; then
        echo "Setting:   $parameter_name to $correct_value"
        echo "$parameter_name,$current_value" >> $log_file
        if [ "$command_name" = "routeadm" ]; then
          if [ "$correct_value" = "disabled" ]; then
            set_command="routeadm -d"
          else
            set_command="routeadm -e"
          fi
          $set_command $parameter_name
        else
          $set_command $parameter_name=$correct_value
        fi
      fi
    fi
  else
    if [ "$audit_mode" != 2 ]; then
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score + 1`
        if [ "$parameter_name" = "tcp_wrappers" ]; then
          echo "Secure:    Service $service_name already has \"$parameter_name\" set to \"$correct_value\""
        else
          echo "Secure:    Output for command $command_name \"$parameter_name\" already set to \"$correct_value\" [$score]"
        fi
      fi
    fi
  fi
}

# Backup file

funct_backup_file () {
  check_file=$1
  backup_file="$work_dir$check_file"
  if [ ! -f "$backup_file" ]; then
    echo "Saving:    File $check_file to $backup_file"
    find $check_file | cpio -pdm $work_dir 2> /dev/null
  fi
}


# Restore file
#
# This routine restores a file from the backup directory to its original
# As par of the restore it also restores the original permissions
#
# check_file      = The name of the original file
# restore_dir     = The directory to restore from

funct_restore_file () {
  check_file=$1
  restore_dir=$2
  restore_file="$restore_dir$check_file"
  if [ -f "$restore_file" ]; then
    sum_check_file=`cksum $check_file |awk '{print $1}'`
    sum_restore_file=`cksum $restore_file |awk '{print $1}'`
    if [ "$sum_check_file" != "$sum_restore_file" ]; then
      echo "Restoring: File $restore_file to $check_file"
      cp -p $restore_file $check_file
      if [ "$os_name" = "SunOS" ]; then
        if [ "$os_version" != "11" ]; then
          pkgchk -f -n -p $check_file 2> /dev/null
        else
          pkg fix `pkg search $check_file |grep pkg |awk '{print $4}'`
        fi
        if [ "$check_file" = "/etc/system" ]; then
          reboot=1
          echo "Notice:    Reboot required"
        fi
      fi
      if [ "$check_file" = "/etc/ssh/sshd_config" ]; then
        echo "Notice:    Service restart required"
      fi
    fi
  fi
}

# Audit file values
#
# This routine takes four values
#
# check_file      = The name of the file to check 
# parameter_name  = The parameter to be checked
# seperator       = Character used to seperate parameter name from it's value (eg =)
# correct_value   = The value we expect to be returned
# comment_value   = Character used as a comment (can be #, *, etc)
#
# If the current_value is not the correct_value then it is fixed if run in lockdown mode
# A copy of the value is stored in a log file, which can be restored

audit_file_value () {
  check_file=$1
  parameter_name=$2
  separator=$3
  correct_value=$4
  comment_value=$5
  total=`expr $total + 1`
  if [ -f "$check_file" ]; then
    if [ "$comment_value" = "star" ]; then
      comment_value="*"
    else
      if [ "$comment_value" = "bang" ]; then
        comment_value="!"
      else
        comment_value="#"
      fi
    fi
    if [ `expr "$separator" : "eq"` = 2 ]; then
      separator="="
      spacer="\="
    else
      if [ `expr "$separator" : "space"` = 5 ]; then
        separator=" "
        spacer=" "
      else
        if [ `expr "$separator" : "colon"` = 5 ]; then
          separator=":"
          space=":"
        fi
      fi
    fi
    if [ "$audit_mode" = 2 ]; then
      funct_restore_file $check_file $restore_dir
    else
      echo "Checking:  Value of \"$parameter_name\" in $check_file is \"$correct_value\""
    fi
    if [ ! -f "$check_file" ]; then
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score - 1`
        echo "Warning:   Parameter \"$parameter_name\" not set to \"$correct_value\" in $check_file [$score]"
      else
        if [ "$audit_mode" = 0 ]; then
          echo "Setting:   Parameter \"$parameter_name\" to \"$correct_value\" in $check_file"
          if [ "$check_file" = "/etc/system" ]; then
            reboot=1
            echo "Notice:    Reboot required"
          fi
          if [ "$check_file" = "/etc/ssh/sshd_config" ]; then
            echo "Notice:    Service restart required"
          fi
          funct_backup_file $check_file
          if [ "$check_file" = "/etc/default/sendmail" ]; then
            echo "$parameter_name$separator\"$correct_value\"" >> $check_file
          else
            echo "$parameter_name$separator$correct_value" >> $check_file
          fi
        fi
      fi
    else
      if [ "$separator" = "tab" ]; then
        check_value=`cat $check_file |grep -v "^$comment_value" |grep "$parameter_name" |awk '{print $2}' |sed 's/"//g' |uniq`
      else
        check_value=`cat $check_file |grep -v "^$comment_value" |grep "$parameter_name" |cut -f2 -d"$separator" |sed 's/"//g' |sed 's/ //g' |uniq`
      fi
      if [ "$check_value" != "$correct_value" ]; then
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score - 1`
          echo "Warning:   Parameter \"$parameter_name\" not set to \"$correct_value\" in $check_file [$score]"
        else
          if [ "$audit_mode" = 0 ]; then
            if [ "$separator" = "tab" ]; then
              check_parameter=`cat $check_file |grep -v "^$comment_value" |grep "$parameter_name" |awk '{print $1}'`
            else  
              check_parameter=`cat $check_file |grep -v "^$comment_value" |grep "$parameter_name" |cut -f1 -d"$separator" |sed 's/ //g' |uniq`
            fi
            echo "Setting:   Parameter \"$parameter_name\" to \"$correct_value\" in $check_file"
            if [ "$check_file" = "/etc/system" ]; then
              reboot=1
              echo "Notice:    Reboot required"
            fi
            if [ "$check_file" = "/etc/ssh/sshd_config" ]; then
              echo "Notice:    Service restart required"
            fi
            funct_backup_file $check_file
            if [ "$check_parameter" != "$parameter_name" ]; then
              if [ "$separator_value" = "tab" ]; then
                echo -e "$parameter_name\t$correct_value" >> $check_file
              else
                echo "$parameter_name$separator$correct_value" >> $check_file
              fi
            else
              if [ "$check_file" = "/etc/default/sendmail" ]; then
                sed "s/^$parameter_name.*/$parameter_name$spacer\"$correct_value\"/" $check_file > $temp_file
              else
                sed "s/^$parameter_name.*/$parameter_name$spacer$correct_value/" $check_file > $temp_file
              fi
              cat $temp_file > $check_file
              if [ "$os_name" = "SunOS" ]; then
                if [ "$os_version" != "11" ]; then
                  pkgchk -f -n -p $check_file 2> /dev/null
                else
                  pkg fix `pkg search $check_file |grep pkg |awk '{print $4}'`
                fi
              fi
              rm $temp_file
            fi
          fi
        fi
      else
        if [ "$audit_mode" != 2 ]; then
          if [ "$audit_mode" = 1 ]; then
            score=`expr $score + 1`
            echo "Secure:    Parameter \"$parameter_name\" already set to \"$correct_value\" in $check_file [$score]"
          fi
        fi
      fi
    fi
  fi
}

# Code to comment out a line

funct_disable_value () {
  check_file=$1
  parameter_name=$2
  comment_value=$3
  total=`expr $total + 1`
  if [ -f "$check_file" ]; then
    if [ "$comment_value" = "star" ]; then
      comment_value="*"
    else
      if [ "$comment_value" = "bang" ]; then
        comment_value="!"
      else
        comment_value="#"
      fi
    fi
    if [ "$audit_mode" = 2 ]; then
      funct_restore_file $check_file $restore_dir
    else
      echo "Checking:  Parameter \"$parameter_name\" in $check_file is disabled"
    fi
    if [ "$separator" = "tab" ]; then
      check_value=`cat $check_file |grep -v "^$comment_value" |grep "$parameter_name" |uniq`
      if [ "$check_value" != "$parameter_name" ]; then
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score - 1`
          echo "Warning:   Parameter \"$parameter_name\" not set to \"$correct_value\" in $check_file [$score]"
        else
          if [ "$audit_mode" = 0 ]; then
            echo "Setting:   Parameter \"$parameter_name\" to \"$correct_value\" in $check_file"
            if [ "$check_file" = "/etc/system" ]; then
              reboot=1
              echo "Notice:    Reboot required"
            fi
            if [ "$check_file" = "/etc/ssh/sshd_config" ]; then
              echo "Notice:    Service restart required"
            fi
            funct_backup_file $check_file
            cat $check_file |sed 's/$parameter_name/$comment_value&' > $temp_file
            cat $temp_file > $check_file
            if [ "$os_name" = "SunOS" ]; then
              if [ "$os_version" != "11" ]; then
                pkgchk -f -n -p $check_file 2> /dev/null
              else
                pkg fix `pkg search $check_file |grep pkg |awk '{print $4}'`
              fi
            fi
            rm $temp_file
          fi
        fi
      else
        if [ "$audit_mode" != 2 ]; then
          if [ "$audit_mode" = 1 ]; then
            score=`expr $score + 1`
            echo "Secure:    Parameter \"$parameter_name\" already set to \"$correct_value\" in $check_file [$score]"
          fi
        fi
      fi
    fi
  fi
}

# Code to append a file with a line
#
# check_file      = The name of the original file
# parameter       = The parameter/line to add to a file
# comment_value   = The character used in the file to distinguish a line as a comment

funct_append_file () {
  check_file=$1
  parameter=$2
  comment_value=$3
  total=`expr $total + 1`
  if [ "$comment_value" = "star" ]; then
    comment_value="*"
  else 
    comment_value="#"
  fi
  if [ "$audit_mode" = 2 ]; then
    restore_file="$restore_dir$check_file"
    if [ -f "$restore_file" ]; then
      diff_check=`diff $check_file $restore_file |wc -l`
      if [ "$diff_check" != 0 ]; then
        funct_restore_file $check_file $restore_dir
        if [ "$check_file" = "/etc/system" ]; then
          reboot=1
          echo "Notice:    Reboot required"
        fi
        if [ "$check_file" = "/etc/ssh/sshd_config" ]; then
          echo "Notice:    Service restart required"
        fi
      fi
    fi
  else
    echo "Checking:  Parameter \"$parameter\" is set in $check_file"
  fi
  if [ ! -f "$check_file" ]; then
    if [ "$audit_mode" = 1 ]; then
      score=`expr $score - 1`
      echo "Warning:   Parameter \"$parameter\" does not exist in $check_file [$score]"
    else
      if [ "$audit_mode" = 0 ]; then
        echo "Setting:   Parameter \"$parameter_name\" in $check_file"
        if [ "$check_file" = "/etc/system" ]; then
          reboot=1
          echo "Notice:    Reboot required"
        fi
        if [ "$check_file" = "/etc/ssh/sshd_config" ]; then
          echo "Notice:    Service restart required"
        fi
        if [ ! -f "$work_dir$check_file" ]; then
          touch $check_file
          funct_backup_file $check_file
        fi
        echo "$parameter" >> $check_file
      fi
    fi
  else
    check_value=`cat $check_file |grep -v '^$comment_value' |grep '$parameter'`
    if [ "$check_value" != "$parameter" ]; then
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score - 1`
        echo "Warning:   Parameter \"$parameter\" does not exist in $check_file [$score]"
      else
        if [ "$audit_mode" = 0 ]; then
          echo "Setting:   Parameter \"$parameter\" in $check_file"
          if [ "$check_file" = "/etc/system" ]; then
            reboot=1
            echo "Notice:    Reboot required"
          fi
          if [ "$check_file" = "/etc/ssh/sshd_config" ]; then
            echo "Notice:    Service restart required"
          fi
          funct_backup_file $check_file
          echo '$parameter' >> $check_file
        fi
      fi
    else
      if [ "$audit_mode" != 2 ]; then
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score + 1`
          echo "Secure:    Parameter \"$parameter\" exists in $check_file [$score]"
        fi
      fi
    fi
  fi
}

# Check to see a file exists and create it or delete it
# 
# check_file    = File to check fo
# check_exists  = If equal to no and file exists, delete it
#                 If equal to yes and file doesn't exist, create it

funct_file_exists () {
  check_file=$1
  check_exists=$2
  log_file="$work_dir/file.log"
  total=`expr $total + 1`
  if [ "$check_exists" = "no" ]; then
    if [ -f "$check_file" ]; then
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score - 1`
        echo "Warning:   File $check_file exists [$score]"
      fi
      if [ "$audit_mode" = 0 ]; then
        echo "Deleting:  $check_file"
        echo "Saving:    File $check_file to $work_dir$check_file"
        find $check_file | cpio -pdm $work_dir 2> /dev/null
        echo "$check_file,rm" >> $log_file
        rm $check_file
      fi
    else
      if [ "$audit_mode" = 2 ]; then
        funct_restore_file $check_file $restore_dir
      fi
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score + 1`
        echo "Secure:    File $check_file does not exist [$score]"
      fi
    fi
  else
    if [ ! -f "$check_file" ]; then
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score - 1`
        echo "Warning:   File $check_file does not exist [$score]"
      fi
      if [ "$audit_mode" = 0 ]; then
        echo "Creating:  File $check_file"
        touch $check_file
        echo "$check_file,touch" >> $log_file
      fi
    else
      if [ "$audit_mode" = 2 ]; then
        funct_restore_file $check_file $restore_dir
      fi
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score - 1`
        echo "Secure:    File $check_file does not exist [$score]"
      fi
    fi
  fi
}

# Get the path the script starts from

start_path=`pwd`

# Get the version of the script from the script itself

script_version=`cd $start_path ; cat $0 | grep '^# Version' |awk '{print $3}'`

# If given no command line arguments print usage information

if [ `expr "$args" : "\-"` != 1 ]; then
  print_usage
fi

# Replace a value in a file with the correct value
#
# As there is no interactive sed on Solaris, ie sed -i
# pipe through sed to a temporary file, then replace original file
# Some handling is added to replace / when searching so sed works
#
# check_file    = File to replace value in
# check_value   = Value to check for
# correct_value = What the value should be
# position      = Position of value in the line

funct_replace_value () {
  check_file=$1
  check_value=$2
  new_check_value="$check_value"
  correct_value=$3
  new_correct_value="$correct_value"
  position=$4
  if [ "$position" = "start" ]; then
    position="^"
  else
    position=""
  fi
  string_check=`expr "$check_value" : "\/"`
  if [ "$string_check" = 1 ]; then
    new_check_value=`echo "$check_value" |sed 's,/,\\\/,g'`
  fi
  string_check=`expr "$correct_value" : "\/"`
  if [ "$string_check" = 1 ]; then
    new_correct_value=`echo "$correct_value" |sed 's,/,\\\/,g'`
  fi
  new_check_value="$position$new_check_value"
  if [ "$audit_mode" != 2 ]; then
    echo "Checking:  File $check_file contains \"$correct_value\" rather than \"$check_value\""
  fi
  check_dfs=`cat $check_file |grep "$new_check_value" |wc -l |sed "s/ //g"`
  if [ "$check_dfs" != 0 ]; then
    if [ "$audit_mode" != 2 ]; then
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score - 1`
        echo "Warning:   File $check_file contains \"$check_value\" rather than \"$correct_value\" [$score]"
      fi
      if [ "$audit_mode" = 0 ]; then
        funct_backup_file $check_file
        echo "Setting:   Share entries in $check_file to be secure"
        sed -e "s/$new_check_value/$new_correct_value/" < $check_file > $temp_file
        cp $temp_file $check_file
        if [ "$os_version" != "11" ]; then
          pkgchk -f -n -p $check_file 2> /dev/null
        else
          pkg fix `pkg search $check_file |grep pkg |awk '{print $4}'`
        fi
        rm $temp_file
      fi
    else
      if [ "$audit_mode" = 2 ]; then
        funct_restore_file $check_file $restore_dir
      fi
    fi
  else
    if [ "$audit_mode" = 1 ]; then
      score=`expr $score + 1`
      echo "Secure:    File $check_file contains \"$correct_value\" rather than \"$check_value\" [$score]"
    fi
  fi
}

# Code to apply patches
# Nothing done with this yet

apply_latest_patches () {
  :
}

# Check is a packae is installed
#
# Install package if it's not installed and in the pkg dir under the base dir
# Needs some more work
#
# pkg_name  = Name of package to search for

audit_check_pkg () {
  if [ "$os_name" = "SunOS" ]; then
    pkg_name=$1
    pkg_check=`pkginfo $1`
    log_file="$work_dir/pkg.log"
    total=`expr $total + 1`
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  Package $pkg_name is installed"
    fi
    if [ `expr "$pkg_check" : "ERROR"` != 5 ]; then
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score + 1`
        echo "Secure:    Package $pkg_name is already installed [$score]"
      fi
    else
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score - 1`
        echo "Warning:   Package $pkg_name is not installed [$score]"
      fi
      if [ "$audit_mode" = 0 ]; then
        pkg_dir="$base_dir/pkg/$pkg_name"
        if [ -d "$pkg_dir" ]; then
          echo "Installing: $pkg_name"
          if [ "$os_version" = "11" ]; then
            :
          else
            pkgadd -d $base_dir/pkg $pkg_name
            pkg_check=`pkginfo $1`
          fi
          if [ `expr "$pkg_check" : "ERROR"` != 5 ]; then
            echo "$pkg_name" >> $log_file
          fi
        fi
      fi
    fi
    if [ "$audit_mode" = 2 ]; then
      restore_file="$restore_dir/pkg.log"
      if [ -f "$restore_file" ]; then
        restore_check=`cat $restore_file |grep "^$pkg_name$" |head -1`
        if [ "$restore_check" = "$pkg_name" ]; then
          echo "Removing:   $pkg_name"
          if [ "$os_version" = "11" ]; then
            pkg uninstall $pkg_name
          else
            pkgrm $pkg_name
          fi
        fi
      fi
    fi
  fi
}

# Install Solaris Encryption Kit on Solaris 10 if it isn't installed
# Needs package installation code done

audit_encryption_kit () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      audit_check_pkg SUNWcry
      audit_check_pkg SUNWcryr
      if [ $os_update -le 4 ]; then
        audit_check_pkg SUNWcryman
      fi
    fi
  fi
}

# Function to audit a svcadm service and enable or disable
#
# service_name    = Name of service
# correct_status  = What the status of the service should be, ie enabled/disabled

audit_svcadm_service () {
  if [ "$os_name" = "SunOS" ]; then
    service_name=$1
    correct_status=$2
    service_exists=`svcs -a |grep "$service_name" | awk '{print $3}'`
    if [ "$service_exists" = "$service_name" ]; then
      total=`expr $total + 1`
      service_status=`svcs -Ho state $service_name`
      file_header="svcadm"
      log_file="$work_dir/$file_header.log"
      if [ "$audit_mode" != 2 ]; then
        echo "Checking:  Service $service_name is $correct_status"
      fi
      if [ "$service_status" != "$correct_status" ]; then
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score - 1`
          echo "Warning:   Service $service_name is enabled [$score]"
        else
          if [ "$audit_mode" = 0 ]; then
            echo "Setting:   Service $service_name to $correct_status"
            echo "Notice:    Previous state stored in $log_file"
            echo "$service_name,$service_status" >> $log_file
            inetadm -d $service_name
            svcadm refresh $service_name
          fi
        fi
      else
        if [ "$audit_mode" = 2 ]; then
          restore_file="$restore_dir/$file_header.log"
          if [ -f "$restore_file" ]; then
            restore_status=`cat $restore_file |grep "^$service_name" |cut -f2 -d','`
            if [ `expr "$restore_status" : "[A-z]"` = 1 ]; then
              if [ "$restore_status" != "$service_status" ]; then
                restore_status=`echo $restore_status |sed 's/online/enable/g' |sed 's/offline/disable/g'`
                echo "Restoring: Service $service_name to $restore_status""d"
                svcadm $restore_status $service_name
                svcadm refresh $service_name
              fi
            fi
          fi
        else
          if [ "$audit_mode" != 2 ]; then
            if [ "$audit_mode" = 1 ]; then
              score=`expr $score + 1`
              echo "Secure:    Service $service_name is already disabled [$score]"
            fi
          fi
        fi
      fi
    fi
  fi
}

# Code to audit an init.d service, and enable, or disable service
#
# service_name    = Name of service
# correct_status  = What the status of the service should be, ie enabled/disabled

audit_initd_service () {
  if [ "$os_name" = "SunOS" ]; then
    service_name=$1
    correct_status=$2
    log_file="initd.log"
    service_check=`ls /etc/init.d |grep "^$service_name$" |wc -l |sed 's/ //g'`
    if [ "$service_check" != 0 ]; then
      if [ "$correct_status" = "disabled" ]; then
        check_file="/etc/init.d/_$service_name"
        if [ -f "$check_file" ]; then
          actual_status="disabled"
        else
          actual_status="enabled"
        fi
      else
        check_file="/etc/init.d/$service_name"
        if [ -f "$check_file" ]; then
          actual_status="enabled"
        else
          actual_status="disabled"
        fi
      fi
      if [ "$audit_mode" != 2 ]; then
        echo "Checking:  If init.d service $service_name is $correct_status"
      fi
      total=`expr $total + 1`
      if [ "$actual_status" != "$correct_status" ]; then
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score - 1`
          echo "Warning:   Service $service_name is not $correct_status [$score]"
        else
          if [ "$audit_mode" = 0 ]; then
            log_file="$work_dir/$log_file"
            echo "$service_name,$actual_status" >> $log_file
            echo "Setting:   Service $service_name to $correct_status"
            if [ "$correct_status" = "disabled" ]; then
              /etc/init.d/$service_name stop
              mv /etc/init.d/$service_name /etc/init.d/_$service_name
            else
              mv /etc/init.d/_$service_name /etc/init.d/$service_name
              /etc/init.d/$service_name start
            fi
          fi
        fi
      else
        if [ "$audit_mode" = 2 ]; then
          restore_file="$restore_dir/$log_file"
          if [ -f "$restore_file" ]; then
            check_name=`cat $restore_file |grep $service_name |cut -f1 -d","`
            if [ "$check_name" = "$service_name" ]; then
              check_status=`cat $restore_file |grep "$service_name" |cut -f2 -d","`
              echo "Restoring: Service $service_name to $check_status"
              if [ "$check_status" = "disabled" ]; then
                /etc/init.d/$service_name stop
                mv /etc/init.d/$service_name /etc/init.d/_$service_name
              else
                mv /etc/init.d/_$service_name /etc/init.d/$service_name
                /etc/init.d/$service_name start
              fi
            fi
          fi
        else
          if [ "$audit_mode" != 2 ]; then
            if [ "$audit_mode" = 1 ]; then
              score=`expr $score + 1`
              echo "Secure:    Service $service_name is $correct_status [$score]"
            fi
          fi
        fi
      fi
    fi
  fi
}

# Code to audit an xinetd service, and enable, or disable
#
# service_name    = Name of service
# correct_status  = What the status of the service should be, ie enabled/disabled

audit_xinetd_service () {
  if [ "$os_name" = "Linux" ]; then
    service_name=$1
    parameter_name=$2
    correct_status=$3
    check_file="/etc/xinetd.d/$service_name"
    log_file="$service_name.log"
    if [ -f "$check_file" ]; then
      actual_status=`cat $check_file |grep $parameter_name |awk '{print $3}'`
      if [ "$audit_mode" != 2 ]; then
        echo "Checking:  If xinetd service $service_name has $parameter_name set to $correct_status"
        total=`expr $total + 1`
        if [ "$actual_status" != "$correct_status" ]; then
          if [ "$audit_mode" = 1 ]; then	
            score=`expr $score - 1`
            echo "Warning:   Service $service_name does not have $parameter_name set to $correct_status [$score]"
          else
            if [ "$audit_mode" = 0 ]; then
              log_file="$work_dir/$log_file"
              echo "$parameter_name,$actual_status" >> $log_file
              echo "Setting:   Parameter $parameter_name for $service_name to $correct_status"
              funct_backup_file $check_file
              if [ "$parameter_name" != "disable" ]; then
                cat $check_file |sed 's/$parameter_name.*/$parameter_name = $correct_status/g' > $temp_file
                cp $temp_file $check_file
              else
                chkconfig $service_name $correct_status
              fi
            fi
          fi
        else
          if [ "$audit_mode" = 1 ]; then
            score=`expr $score + 1`
            echo "Secure:    Service $service_name has $parameter_name set to $correct_status [$score]"
          fi
        fi
      else
        restore_file="$restore_dir/$log_file"
        if [ -f "$restore_file" ]; then
          check_name=`cat $restore_file |grep $service_name |cut -f1 -d","`
          if [ "$check_name" = "$service_name" ]; then
            check_status=`cat $restore_file |grep $service_name |cut -f2 -d","`
            if [ "$actual_status" != "$check_status" ]; then
              funct_restore_file $check_file $restore_dir
            fi
          fi
        else
          echo "Result:    Nothing to restore for service $service_name"
        fi
      fi
    fi
  fi
}

# Code to audit a service managed by chkconfig, and enable, or disbale
#
# service_name    = Name of service
# correct_status  = What the status of the service should be, ie enabled/disabled

audit_chkconfig_service () {
  if [ "$os_name" = "Linux" ]; then
    service_name=$1
    service_level=$2
    correct_status=$3
    log_file="chkconfig.log"
    if [ "$service_level" = "3" ]; then
      actual_status=`chkconfig --list $service_name 2> /dev/null |awk '{print $5}' |cut -f2 -d':' |awk '{print $1}'`
    fi
    if [ "$service_level" = "5" ]; then
      actual_status=`chkconfig --list $service_name 2> /dev/null |awk '{print $7}' |cut -f2 -d':' |awk '{print $1}'`
    fi
    if [ "$actual_status" = "on" ] || [ "$actual_status" = "off" ]; then
      if [ "$audit_mode" != 2 ]; then
        echo "Checking:  Service $service_name at run level $service_level is $correct_status"
      fi
      if [ "$actual_status" != "$correct_status" ]; then
        total=`expr $total + 1`
        if [ "$audit_mode" != 2 ]; then
          if [ "$audit_mode" = 1 ]; then	
            score=`expr $score - 1`
            echo "Warning:   Service $service_name is not $correct_status [$score]"
          else
            if [ "$audit_mode" = 0 ]; then
              log_file="$work_dir/$log_file"
              echo "$service_name,$service_level,$actual_status" >> $log_file
              echo "Setting:   Service $service_name at run level $service_level to $correct_status"
              chkconfig --level $service_level $correct_status
            fi
          fi
        fi
      else
        if [ "$audit_mode" != 2 ]; then
          if [ "$audit_mode" = 1 ]; then
            score=`expr $score + 1`
            echo "Secure:    Service $service_name at run level $service_level is $correct_status [$score]"
          fi
        fi
      fi
      if [ "$audit_mode" = 2 ]; then
        restore_file="$restore_dir/$log_file"
        if [ -f "$restore_file" ]; then
          check_status=`cat $restore_file |grep $service_name |grep ",$service_level," |cut -f3 -d","`
          if [ "$check_status" = "$actual_status" ]; then
            echo "Restoring: Service $service_name at run level $service_level to $check_status"
            chkconfig --level $service_level $check_status
          fi
        else
          echo "Result:    Nothing to restore for service $service_name"
        fi
      fi
    fi
  fi
}

# Service audit routine wrapper, sends to appropriate function based on service type
#
# service_name    = Name of service
# correct_status  = What the status of the service should be, ie enable/disabled

audit_service () {
  if [ "$os_name" = "SunOS" ]; then
    service_name=$1
    correct_status=$2
    if [ `expr "$service_name" : "svc:"` = 4 ]; then
      audit_svcadm_service $service_name $correct_status
    else
      audit_initd_service $service_name $correct_status
      audit_inetd_service $service_name $correct_status
    fi
  fi
}

# Disable Local CDE ToolTalk Database Server

audit_cde_ttdb () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      service_name="svc:/network/rpc/cde-ttdbserver:tcp"
      audit_service $service_name disabled
    fi
  fi
}

# Disable Local CDE Calendar Manager

audit_cde_cal () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      service_name="svc:/network/rpc/cde-calendar-manager:default"
      audit_service $service_name disabled
    fi
  fi
}

# Disable Subprocess control

audit_cde_spc () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      service_name="svc:/network/cde-spc:default"
      audit_service $service_name disabled
    fi
  fi
}

# Disable OpenGL

audit_opengl () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      service_name="svc:/application/opengl/ogl-select:default"
      audit_service $service_name disabled
    fi
  fi
}

# Disable CDE Print

audit_cde_print () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      service_name="svc:/application/cde-printinfo:default"
      audit_service $service_name disabled
    fi
  fi
}

# Disable PPD cache

audit_ppd_cache () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      service_name="svc:/application/print/ppd-cache-update:default"
      audit_service $service_name disabled
    fi
  fi
}

# Audit gdm.conf

audit_gdm_conf () {
  if [ "$os_name" = "Linux" ]; then
    check_file="/etc/X11/gdm/gdm.conf"
    if [ -e "$check_file" ]; then
      audit_file_value $check_file AllowRoot eq false hash
      audit_file_value $check_file AllowRemoteRoot eq false hash
      audit_file_value $check_file Use24Clock eq true hash
      audit_check_perms $check_file 0644 root root
    fi
  fi
}

# Disable Local Graphical Login Environment
# Turn off XDMCP listening

audit_xlogin () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      service_name="svc:/application/graphical-login/cde-login"
      audit_service $service_name disabled
      service_name="svc:/application/gdm2-login"
      audit_service $service_name disabled
    fi
    if [ "$os_version" = "11" ]; then
      service_name="svc:/application/graphical_login/gdm:default"
      audit_service $service_name disabled
    fi
    if [ "$os_version" = "10" ]; then
      service_name="dtlogin"
      audit_service $service_name disabled
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    check_file="/etc/X11/xdm/Xresources"
    if [ -f "$check_file" ]; then
      total=`expr $total + 1`
      if [ "$audit_mode" != 2 ]; then
        greet_check=`cat $check_file |grep 'private system' |wc -l`
        if [ "$greet_check" != 1 ]; then
           echo "Checking:  Checking $check_file for security message"
           if [ "$audit_mode" = 1 ]; then
             score=`expr $score - 1`
             echo "Warning:   File $check_file does not have a security message [$score]"
           else
             echo "Setting:   Security message in $check_file"
             greet_mesg="This is a private system --- Authorized use only!"
             funct_backup_file $check_file
             cat $check_file |awk '/xlogin\*greeting:/ { print GreetValue; next }; { print }' GreetValue="$greet_mesg" > $temp_file
             cat $temp_file > $check_file
             rm $temp_file
           fi
        else
          score=`expr $score + 1`
          echo "Secure:    File $check_file has security message [$score]"
        fi
      else
        funct_restore_file $check_file $restore_dir
      fi  
    fi
    check_file="/etc/X11/xdm/kdmrc"
    if [ -f "$check_file" ]; then
      total=`expr $total + 1`
      if [ "$audit_mode" != 2 ]; then
        greet_check= `cat $check_file |grep 'private system' |wc -l`
        if [ "$greet_check" != 1 ]; then
           echo "Checking:  File $check_file for security message"
           if [ "$audit_mode" = 1 ]; then
             score=`expr $score - 1`
             echo "Warning:   File $check_file does not have a security message [$score]"
           else
             echo "Setting:   Security message in $check_file"
             greet_mesg="This is a private system --- Authorized USE only!"
             funct_backup_file $check_file
             cat $check_file |awk '/GreetString=/ { print "GreetString=" GreetString; next }; { print }' GreetString="$greet_mesg" > $temp_file
             cat $temp_file > $check_file
             rm $temp_file
           fi
        else
          score=`expr $score + 1`
          echo "Secure:    File $check_file has security message [$score]"
        fi
      else
        funct_restore_file $check_file $restore_dir
      fi  
    fi
    check_file="/etc/X11/xdm/Xservers"
    if [ -f "$check_file" ]; then
      total=`expr $total + 1`
      if [ "$audit_mode" != 2 ]; then
        greet_check=`cat $check_file |grep 'nolisten tcp' |wc -l`
        if [ "$greet_check" != 1 ]; then
           echo "Checking:  For X11 nolisten directive in $check_file"
           if [ "$audit_mode" = 1 ]; then
             score=`expr $score - 1`
             echo "Warning:   X11 nolisten directive not found in $check_file [$score]"
           else
             echo "Setting:   Security message in $check_file"
             funct_backup_file $check_file
             cat $check_file |awk '( $1 !~ /^#/ && $3 == "/usr/X11R6/bin/X" ) { $3 = $3 " -nolisten tcp" }; { print }' > $temp_file
             cat $check_file |awk '( $1 !~ /^#/ && $3 == "/usr/bin/X" ) { $3 = $3 " -nolisten tcp" }; { print }' > $temp_file
             cat $temp_file > $check_file
             rm $temp_file
           fi
        else
          score=`expr $score + 1`
          echo "Secure:    X11 nolisten directive found in $check_file [$score]"
        fi
      else
        funct_restore_file $check_file $restore_dir
      fi  
    fi
  fi
}

# Audit inittab

audit_inittab () {
  check_file="/etc/inittab"
  audit_check_perms $check_file 0600 root root
}

# Disable Local sendmail Service
# Need to add code to disable relay if enabled

audit_sendmail_daemon () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/smtp:sendmail"
      audit_service $service_name disabled
    fi
    if [ "$os_version" = "10" ]; then
      service_name="sendmail"
      audit_service $service_name disabled
    fi
    if [ "$os_version" = "9" ] || [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      check_file="/etc/default/sendmail"
      audit_file_value $check_file QUEUEINTERVAL eq 15m hash
      funct_append_file $check_file "MODE=" hash
    else
      audit_initd_service sendmail disable
      check_file="/var/spool/cron/crontabs/root"
      check_string="0 * * * * /usr/lib/sendmail -q"
      funct_append_file $check_file $check_string has
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    audit_chkconfig_service sendmail 3 off
    audit_chkconfig_service sendmail 5 off
    check_file="/etc/sysconfig/sendmail"
    audit_file_value $check_file DAEMON eq no hash
    audit_file_value $check_file QUEUE eq 1h hash
  fi
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    check_file="/etc/mail/sendmail.cf"
    search_string="Addr=127.0.0.1"
    restore=0
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  Mail transfer agent is running in local-only mode"
      total=`expr $total + 1`
      check_value=`cat $check_file |grep -v '^#' |grep 'O DaemonPortOptions' |awk '{print $3}' |grep '$search_string'`
      if [ "$check_value" = "$search_string" ]; then
        if [ "$audit_mode" = "1" ]; then
          score=`expr $score - 1`
          echo "Warning:   Mail transfer agent is not running in local-only mode [$score]"
        fi
        if [ "$audit_mode" = 0 ]; then
          funct_backup_file $check_file 
          echo "Setting:   Mail transfer agent to run in local-only mode"
          cp $check_file $temp_file
          cat $temp_file |awk 'O DaemonPortOptions=/ { print "O DaemonPortOptions=Port=smtp, Addr=127.0.0.1, Name=MTA"; next} { print }' > $check_file
          rm $temp_file
        fi
      else
        if [ "$audit_mode" = "1" ]; then  
          score=`expr $score + 1`
          echo "Secure:    Mail transfer agent is running in local-only mode [$score]"
        fi
      fi
    else
      funct_restore_file $check_file $restore_dir
    fi
  fi
}

# Disable Local Web Console

audit_webconsole () {
  if [ "$os_version" = "10" ]; then
    service_name="svc:/system/webconsole:console"
    audit_service $service_name disabled
  fi
}

# Disable Local WBEM

audit_wbem () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      service_name="svc:/application/management/wbem"
      audit_service $service_name disabled
    fi
  fi
}

# Disable Local BSD Print Protocol Adapter

audit_print () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      service_name="svc:/application/print/ipp-listener:default"
      audit_service $service_name disabled
      service_name="svc:/application/print/rfc1179"
      audit_service $service_name disabled
      service_name="svc:/application/print/server:default"
      audit_service $service_name disabled
    fi
  fi
}

# Disable RPC Encryption Key

audit_keyserv () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/rpc/keyserv"
      audit_service $service_name disabled
    fi
  fi
}

# Disable NIS Server Daemons

audit_nis_server () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      service_name="svc:/network/nis/server"
      audit_service $service_name disabled
      service_name="svc:/network/nis/passwd"
      audit_service $service_name disabled
      service_name="svc:/network/nis/update"
      audit_service $service_name disabled
      service_name="svc:/network/nis/xfr"
      audit_service $service_name disabled
    fi
    if [ "$os_version" = "11" ]; then
      service_name="svc:/network/nis/server"
      audit_service $service_name disabled
      service_name="svc:/network/nis/domain"
      audit_service $service_name disabled
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    for service_name in yppasswdd ypserv ypxfrd; do
      audit_chkconfig_service $service_name 3 off
      audit_chkconfig_service $service_name 5 off
    done
  fi
}

# Disable NIS Client Daemons

audit_nis_client () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/nis/client"
      audit_service $service_name disabled
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    service_name="ypbind"
    audit_chkconfig_service $service_name 3 off
    audit_chkconfig_service $service_name 5 off
  fi
}

# Disable NIS+ Daemons

audit_nisplus () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      service_name="svc:/network/rpc/nisplus"
      audit_service $service_name disabled
    fi
  fi
}

# Disable LDAP Cache Manager

audit_ldap_cache () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      service_name="svc:/network/ldap/client"
      audit_service $service_name disabled
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    service_name="ldap"
    audit_chkconfig_service $service_name 3 off
    audit_chkconfig_service $service_name 5 off
  fi
}

# Disable Kerberos TGT Expiration Warning
# Need to add code to check if kerberos is being used

audit_kerberos_tgt () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/security/ktkt_warn"
      audit_service $service_name disabled
    fi
  fi
}

# Disable Generic Security Services (GSS) Daemons
# Need to add code to check if kerberos is being used

audit_gss () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/rpc/gss"
      audit_service $service_name disabled
    fi
  fi
}

# Disable Volume Manager
# Need to add code to see if something is mounted and warn

audit_volfs () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      service_name="svc:/system/filesystem/volfs"
      audit_service $service_name disabled
    fi
    if [ "$os_version" = "11" ]; then
      service_name="svc:/system/filesystem/rmvolmgr"
      audit_service $service_name disabled
    fi
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/rpc/smserver"
      audit_service $service_name disabled
    fi
    if [ "$os_version" = "10" ]; then
      service_name="volmgt"
      audit_service $service_name disabled
    fi
  fi
}

# Disable Samba Support
# Need to add code to see if samba is being used

audit_samba () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      if [ $os_update -ge 4 ]; then
        service_name="svc:/network/samba"
        audit_service $service_name disabled
      else
        service_name="samba"
        audit_service $service_name disabled
      fi
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    service_name="smb"
    audit_chkconfig_service $service_name 3 off
    audit_chkconfig_service $service_name 5 off
  fi
}

# Disable automount Daemon
# Need to add code to see if automounter is in use and warn

audit_autofs () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/system/filesystem/autofs"
      audit_service $service_name disabled
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    service_name="autofs"
    audit_chkconfig_service $service_name 3 off
    audit_chkconfig_service $service_name 5 off
  fi
}

# Disable Apache Services
# Need to add code to see if apache is in use and warn

audit_apache () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      service_name="svc:/network/http:apache2"
      audit_service $service_name disabled
    fi
    if [ "$os_version" = "11" ]; then
      service_name="svc:/network/http:apache22"
      audit_service $service_name disabled
    fi
    if [ "$os_version" = "10" ]; then
      service_name="apache"
      audit_service $service_name disabled
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    for service_name in httpd apache tomcat5 squid prixovy; do
      audit_chkconfig_service $service_name 3 off
      audit_chkconfig_service $service_name 5 off
    done
  fi
}

# Disable Solaris Volume Manager Services

audit_svm () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      service_name="svc:/system/metainit"
      audit_service $service_name disabled
      service_name="svc:/system/mdmonitor"
      audit_service $service_name disabled
      if [ $os_update -lt 4 ]; then
        service_name="svc:/platform/sun4u/mpxio-upgrade"
      else
        service_name="svc:/system/device/mpxio-upgrade"
      fi
      audit_service $service_name disabled
    fi
  fi
}

# Disable Solaris Volume Manager GUI

audit_svm_gui () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      service_name="svc:/network/rpc/mdcomm"
      audit_service $service_name disabled
      service_name="svc:/network/rpc/meta"
      audit_service $service_name disabled
      service_name="svc:/network/rpc/metamed"
      audit_service $service_name disabled
      service_name="svc:/network/rpc/metamh"
      audit_service $service_name disabled
    fi
  fi
}

# Disable Local RPC Port Mapping Service

audit_svccfg_value () {
  if [ "$os_name" = "SunOS" ]; then
    service_name=$1
    service_property=$2
    correct_value=$3
    current_value=`svccfg -s $service_name listprop $service_property |awk '{print $3}'`
    file_header="svccfg"
    log_file="$work_dir/$file_header.log"
    total=`expr $total + 1`
    if [ "$audit_mode" = 2 ]; then
      restore_file="$restore_dir/$file_header.log"
      if [ -f "$restore_file" ]; then
        restore_property=`cat $restore_file |grep "$service_name" |cut -f2 -d','`
        restore_value=`cat $restore_file |grep "$service_name" |cut -f3 -d','`
        if [ `expr "$restore_property" : "[A-z]"` = 1 ]; then
          if [ "$current_value" != "$restore_vale" ]; then
            echo "Restoring: $service_name $restore_propert to $restore_value"
            svccfg -s $service_name setprop $restore_property = $restore_value
          fi
        fi
      fi
    else
      echo "Checking:  Service $service_name"
    fi
    if [ "$current_value" != "$correct_value" ]; then
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score - 1`
        echo "Warning:   Service $service_name $service_property not set to $correct_value [$score]"
      else
        if [ "$audit_mode" = 0 ]; then
          echo "Setting:   $service_name $service_propery to $correct_value"
          echo "$service_name,$service_property,$current_value" >> $log_file
          svccfg -s $service_name setprop $service_property = $correct_value
        fi
      fi
    else
      if [ "$audit_mode" != 2 ]; then
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score + 1`
          echo "Secure:    Service $service_name $service_property already set to $correct_value [$score]"
        fi
      fi
    fi
  fi
}

# Disable rpc bind on Solaris 11
# Check that rpc bind has tcp wrappers enable in case it's turned on

audit_rpc_bind () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/rpc/bind"
      service_property="config/enable_tcpwrappers"
      correct_value="true"
      audit_svccfg_value $service_name $service_property $correct_value
    fi
    if [ "$os_version" = "11" ]; then
      service_name="svc:/network/rpc/bind"
      audit_service $service_name disabled
    fi
  fi
}

# Establish a Secure Baseline
# This uses the Solaris 10 svcadm baseline
# Don't really need this so haven't coded anything for it yet

secure_baseline () {
  :
}

# Configure TCP Wrappers

audit_tcp_wrappers () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      audit_rpc_bind
      for service_name in `inetadm |awk '{print $3}' |grep "^svc"`; do
        audit_command_value inetadm tcp_wrappers TRUE $service_name
      done
    fi
  fi
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    check_file="/etc/hosts.deny"
    audit_file_value $check_file ALL colon " ALL" hash
    check_file="/etc/hosts.allow"
    audit_file_value $check_file ALL colon " localhost" hash
    audit_file_value $check_file ALL colon " 127.0.0.1" hash
    if [ ! -f "$check_file" ]; then
      for ip_address in `ifconfig -a |grep 'inet addr' |grep -v ':127.' |awk '{print $2}' |cut -f2 -d":"`; do
        netmask=`ifconfig -a |grep '$ip_address' |awk '{print $3}' |cut -f2 -d":"`
        audit_file_value $check_file ALL colon " $ip_address/$netmask" hash
      done
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    package_name="tcp_wrappers"
    total=`expr $total + 1`
    log_file="ntp.log"
    audit_linux_package check $package_name
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  TCP Wrappers is installed"
    fi
    if [ "$package_name" != "ntp" ]; then
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score - 1`
        echo "Warning:   TCP Wrappers is not installed [$score]"
      fi
      if [ "$audit_mode" = 0 ]; then
        echo "Setting:   TCP Wrappers to installed"
        log_file="$work_dir/$log_file"
        echo "Installed $package_name" >> $log_file
        audit_linux_package install $package_name
      fi
    else
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score + 1`
        echo "Secure:    TCP Wrappers is installed [$score]"
      fi
      if [ "$audit_mode" = 2 ]; then
        restore_file="$restore_dir/$log_file"
        audit_linux_package restore $package_name $restore_file
      fi
    fi
  fi
}

# Modify Network Parameters
# Checks and sets ndd values

audit_ndd_value () {
  if [ "$os_version" = "10" ]; then
    ndd_name=$1
    ndd_property=$2
    correct_value=$3
    total=`expr $total + 1`
    if [ "$ndd_property" = "tcp_extra_priv_ports_add" ]; then
      current_value=`ndd -get $ndd_name tcp_extra_priv_ports |grep "$correct_value"`
    else
      current_value=`ndd -get $ndd_name $ndd_property`
    fi
    file_header="ndd"
    log_file="$work_dir/$file_header.log"
    if [ "$audit_mode" = 2 ]; then
      restore_file="$restore_dir/$file_header.log"
      if [ -f "$restore_file" ]; then
        restore_property=`cat $restore_file |grep "$ndd_property," |cut -f2 -d','`
        restore_value=`cat $restore_file |grep "$ndd_property," |cut -f3 -d','`
        if [ `expr "$restore_property" : "[A-z]"` = 1 ]; then
          if [ "$ndd_property" = "tcp_extra_priv_ports_add" ]; then
            current_value=`ndd -get $ndd_name tcp_extra_priv_ports |grep "$restore_value" |wc -l`
          fi
          if [ `expr "$current_value" : "[1-9]"` = 1 ]; then
            if [ "$current_value" != "$restore_value" ]; then
              if [ "$ndd_property" = "tcp_extra_priv_ports_add" ]; then
                ndd_property="tcp_extra_priv_ports_del"
              fi
              echo "Restoring: $ndd_name $ndd_property to $restore_value"
              ndd -set $ndd_name $ndd_property $restore_value
            fi
          fi
        fi
      fi
    else
      echo "Checking:  NDD $ndd_name $ndd_property"
    fi
    if [ "$current_value" -ne "$correct_value" ]; then
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score - 1`
        echo "Warning:   NDD \"$ndd_name $ndd_property\" not set to \"$correct_value\" [$score]"
      else
        if [ "$audit_mode" = 0 ]; then
          echo "Setting:   NDD \"$ndd_name $ndd_property\" to \"$correct_value\""
          echo "$ndd_name,$ndd_property,$correct_value" >> $log_file
          ndd -set $ndd_name $ndd_property $correct_value
        fi
      fi
    else
      if [ "$audit_mode" != 2 ]; then
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score + 1`
          echo "Secure:    NDD \"$ndd_name $ndd_property\" already set to \"$correct_value\" [$score]"
        fi
      fi
    fi
  fi
}

# Code to audit ndd values and create init script so change survives a reboot

audit_kernel_params () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" != "11" ]; then
      check_file="/etc/init.d/ndd-netconfig"
      rcd_file="/etc/rc2.d/S99ndd-netconfig"
      if [ "$audit_mode" = 0 ]; then
        if [ ! -f "$check_file" ]; then
          echo "Creating:  Init script $check_file"
          echo "#!/sbin/sh" > $check_file
          echo "case \"\$1\" in" >> $check_file
          echo "start)" >> $check_file
          echo "\t/usr/sbin/ndd -set /dev/ip ip_forward_src_routed 0" >> $check_file
          echo "\t/usr/sbin/ndd -set /dev/ip ip_forwarding 0" >> $check_file
          if [ "$os_version" = "8" ] || [ "$os_version" = "9" ] || [ "$os_version" = "10" ]; then
            echo "\t/usr/sbin/ndd -set /dev/ip ip6_forward_src_routed 0" >> $check_file
            echo "\t/usr/sbin/ndd -set /dev/tcp tcp_rev_src_routes 0" >> $check_file
            echo "\t/usr/sbin/ndd -set /dev/ip ip6_forwarding 0" >> $check_file
          fi
          echo "\t/usr/sbin/ndd -set /dev/ip ip_forward_directed_broadcasts 0" >> $check_file
          echo "\t/usr/sbin/ndd -set /dev/tcp tcp_conn_req_max_q0 4096" >> $check_file
          echo "\t/usr/sbin/ndd -set /dev/tcp tcp_conn_req_max_q 1024" >> $check_file
          echo "\t/usr/sbin/ndd -set /dev/ip ip_respond_to_timestamp 0" >> $check_file
          echo "\t/usr/sbin/ndd -set /dev/ip ip_respond_to_timestamp_broadcast 0" >> $check_file
          echo "\t/usr/sbin/ndd -set /dev/ip ip_respond_to_address_mask_broadcast 0" >> $check_file
          echo "\t/usr/sbin/ndd -set /dev/ip ip_respond_to_echo_multicast 0" >> $check_file
          if [ "$os_version" = "8" ] || [ "$os_version" = "9" ] || [ "$os_version" = "10" ]; then
            echo "\t/usr/sbin/ndd -set /dev/ip ip6_respond_to_echo_multicast 0" >> $check_file
          fi
          echo "\t/usr/sbin/ndd -set /dev/ip ip_respond_to_echo_broadcast 0" >> $check_file
          echo "\t/usr/sbin/ndd -set /dev/arp arp_cleanup_interval 60000" >> $check_file
          echo "\t/usr/sbin/ndd -set /dev/ip ip_ire_arp_interval 60000" >> $check_file
          echo "\t/usr/sbin/ndd -set /dev/ip ip_ignore_redirect 1" >> $check_file
          if [ "$os_version" = "8" ] || [ "$os_version" = "9" ] || [ "$os_version" = "10" ]; then
            echo "\t/usr/sbin/ndd -set /dev/ip ip6_ignore_redirect 1" >> $check_file
          fi
          echo "\t/usr/sbin/ndd -set /dev/tcp tcp_extra_priv_ports_add 6112" >> $check_file
          echo "\t/usr/sbin/ndd -set /dev/ip ip_strict_dst_multihoming 1" >> $check_file
          if [ "$os_version" = "8" ] || [ "$os_version" = "9" ] || [ "$os_version" = "10" ]; then
            echo "\t/usr/sbin/ndd -set /dev/ip ip6_strict_dst_multihoming 1" >> $check_file
          fi
          echo "\t/usr/sbin/ndd -set /dev/ip ip_send_redirects 0" >> $check_file
          if [ "$os_version" = "8" ] || [ "$os_version" = "9" ] || [ "$os_version" = "10" ]; then
            echo "\t/usr/sbin/ndd -set /dev/ip ip6_send_redirects 0" >> $check_file
          fi
          echo "esac" >> $check_file
          echo "exit 0" >> $check_file
          chmod 750 $check_file
          if [ ! -f "$rcd_file" ]; then
            ln -s $check_file $rcd_file
          fi
        fi
      fi
      audit_ndd_value /dev/ip ip_forward_src_routed 0
      audit_ndd_value /dev/ip ip_forwarding 0
      if [ "$os_version" = "8" ] || [ "$os_version" = "9" ] || [ "$os_version" = "10" ]; then
        audit_ndd_value /dev/ip ip6_forward_src_routed 0
        audit_ndd_value /dev/tcp tcp_rev_src_routes 0
        audit_ndd_value /dev/ip ip6_forwarding 0
      fi
      audit_ndd_value /dev/ip ip_forward_directed_broadcasts 0
      audit_ndd_value /dev/tcp tcp_conn_req_max_q0 4096
      audit_ndd_value /dev/tcp tcp_conn_req_max_q 1024
      audit_ndd_value /dev/ip ip_respond_to_timestamp 0
      audit_ndd_value /dev/ip ip_respond_to_timestamp_broadcast 0
      audit_ndd_value /dev/ip ip_respond_to_address_mask_broadcast 0
      audit_ndd_value /dev/ip ip_respond_to_echo_multicast 0
      if [ "$os_version" = "8" ] || [ "$os_version" = "9" ] || [ "$os_version" = "10" ]; then
        audit_ndd_value /dev/ip ip6_respond_to_echo_multicast 0
      fi
      audit_ndd_value /dev/ip ip_respond_to_echo_broadcast 0
      audit_ndd_value /dev/arp arp_cleanup_interval 60000
      audit_ndd_value /dev/ip ip_ire_arp_interval 60000
      audit_ndd_value /dev/ip ip_ignore_redirect 1
      if [ "$os_version" = "8" ] || [ "$os_version" = "9" ] || [ "$os_version" = "10" ]; then
        audit_ndd_value /dev/ip ip6_ignore_redirect 1
      fi
      audit_ndd_value /dev/tcp tcp_extra_priv_ports_add 6112
      audit_ndd_value /dev/ip ip_strict_dst_multihoming 1
      if [ "$os_version" = "8" ] || [ "$os_version" = "9" ] || [ "$os_version" = "10" ]; then
        audit_ndd_value /dev/ip ip6_strict_dst_multihoming 1
      fi
      audit_ndd_value /dev/ip ip_send_redirects 0
      if [ "$os_version" = "8" ] || [ "$os_version" = "9" ] || [ "$os_version" = "10" ]; then
        audit_ndd_value /dev/ip ip6_send_redirects 0
      fi
    fi
    if [ "$audit_mode" = 2 ]; then
      if [ -f "$check_file" ]; then
        funct_file_exists $check_file no
      fi
    fi
  fi
}

# Restrict Core Dumps to Protected Directory
#
# Although /etc/coreadm.conf isn't strictly needed,
# creating it and importing it makes it easier to
# enable or disable changes
#
# Example /etc/coreadm.conf
#
# COREADM_GLOB_PATTERN=/var/cores/core_%n_%f_%u_%g_%t_%p
# COREADM_INIT_PATTERN=core
# COREADM_GLOB_ENABLED=yes
# COREADM_PROC_ENABLED=no
# COREADM_GLOB_SETID_ENABLED=yes
# COREADM_PROC_SETID_ENABLED=no
# COREADM_GLOB_LOG_ENABLED=yes

audit_core_dumps () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" != "6" ]; then
      cores_dir="/var/cores"
      check_file="/etc/coreadm.conf"
      cores_check=`coreadm |head -1 |awk '{print $5}'`
      total=`expr $total + 1`
      if [ `expr "$cores_check" : "/var/cores"` != 10 ]; then
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score - 1`
          echo "Warning:   Cores are not restricted to a private directory [$score]"
        else
          if [ "$audit_mode" = 0 ]; then
            echo "Setting:   Making sure restricted to a private directory"
            if [ -f "$check_file" ]; then
              echo "Saving:    File $check_file to $work_dir$check_file"
              find $check_file | cpio -pdm $work_dir 2> /dev/null
            else
              touch $check_file
              find $check_file | cpio -pdm $work_dir 2> /dev/null
              rm $check_file
              log_file="$work_dir/$check_file"
              coreadm | sed -e 's/^ *//g' |sed 's/ /_/g' |sed 's/:_/:/g' |awk -F: '{ print $1" "$2 }' | while read option value; do
                if [ "$option" = "global_core_file_pattern" ]; then
                  echo "COREADM_GLOB_PATTERN=$value" > $log_file
                fi
                if [ "$option" = "global_core_file_content" ]; then
                  echo "COREADM_GLOB_CONTENT=$value" >> $log_file
                fi
                if [ "$option" = "init_core_file_pattern" ]; then
                  echo "COREADM_INIT_PATTERN=$value" >> $log_file
                fi
                if [ "$option" = "init_core_file_content" ]; then
                  echo "COREADM_INIT_CONTENT=$value" >> $log_file
                fi
                if [ "$option" = "global_core_dumps" ]; then
                  if [ "$value" = "enabled" ]; then
                    value="yes"
                  else
                    value="no"
                  fi
                  echo "COREADM_GLOB_ENABLED=$value" >> $log_file
                fi
                if [ "$option" = "per-process_core_dumps" ]; then
                  if [ "$value" = "enabled" ]; then
                    value="yes"
                  else
                    value="no"
                  fi
                  echo "COREADM_PROC_ENABLED=$value" >> $log_file
                fi
                if [ "$option" = "global_setid_core_dumps" ]; then
                  if [ "$value" = "enabled" ]; then
                    value="yes"
                  else
                    value="no"
                  fi
                  echo "COREADM_GLOB_SETID_ENABLED=$value" >> $log_file
                fi
                if [ "$option" = "per-process_setid_core_dumps" ]; then
                  if [ "$value" = "enabled" ]; then
                    value="yes"
                  else
                    value="no"
                  fi
                  echo "COREADM_PROC_SETID_ENABLED=$value" >> $log_file
                fi
                if [ "$option" = "global_core_dump_logging" ]; then
                  if [ "$value" = "enabled" ]; then
                    value="yes"
                  else
                    value="no"
                  fi
                  echo "COREADM_GLOB_LOG_ENABLED=$value" >> $log_file
                fi
              done
            fi
            coreadm -g /var/cores/core_%n_%f_%u_%g_%t_%p -e log -e global -e global-setid -d process -d proc-setid
          fi
          if [ ! -d "$cores_dir" ]; then
            mkdir $cores_dir
            chmod 700 $cores_dir
            chown root:root $cores_dir
          fi
        fi
      else
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score + 1`
          echo "Secure:    Cores are restricted to a private directory [$score]"
        fi
      fi
      if [ "$audit_mode" = 2 ]; then
        funct_restore_file $check_file $restore_dir
        restore_file="$restore_dir$check_file"
        if [ -f "$restore_file" ]; then
          coreadm -u
        fi
      fi
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    for service_name in kdump; do
      audit_chkconfig_service $service_name 3 off
      audit_chkconfig_service $service_name 5 off
    done
  fi
}

# Enable Stack Protection
#
# Checks for the following values in /etc/system:
#
# set noexec_user_stack=1
# set noexec_user_stack_log=1

audit_stack_protection () {
  if [ "$os_name" = "SunOS" ]; then
    check_file="/etc/system"
    audit_file_value $check_file "set noexec_user_stack" eq 1 star
    audit_file_value $check_file "set noexec_user_stack_log" eq 1 star
  fi
}

# Enable Strong TCP Sequence Number Generation
#
# Checks for the following values in /etc/default/inetinit:
#
# TCP_STRONG_ISS=2

audit_tcp_strong_iss () {
  if [ "$os_name" = "SunOS" ]; then
    check_file="/etc/default/inetinit"
    audit_file_value $check_file TCP_STRONG_ISS eq 2 hash
    if [ "$os_version" != "11" ]; then
      audit_ndd_value /dev/tcp tcp_strong_iss 2
    fi
    if [ "$os_version" = "11" ]; then
      audit_ipadm_value _strong_iss tcp 2
    fi
  fi
}

# Code to drive ipadm on Solaris 11

audit_ipadm_value () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "11" ]; then
      ipadm_name=$1
      ipadm_property=$2
      correct_value=$3
      current_value=`ipadm show-prop -p $ipadm_name -co current $ipadm_property`
      file_header="ipadm"
      total=`expr $total + 1`
      log_file="$work_dir/$file_header.log"
      if [ "$audit_mode" = 2 ]; then
        restore_file="$restore_dir/$file_header.log"
        if [ -f "$restore_file" ]; then
          restore_property=`cat $restore_file |grep "$ipadm_property," |cut -f2 -d','`
          restore_value=`cat $restore_file |grep "$ipadm_property," |cut -f3 -d','`
          if [ `expr "$restore_property" : "[A-z]"` = 1 ]; then
            if [ "$current_value" != "$restore_value" ]; then
              echo "Restoring: $ipadm_name $ipadm_property to $restore_value"
              ipadm set-prop -p $ipadm_name=$restore_value $ipadm_property
            fi
          fi
        fi
      else
        echo "Checking:  Value of \"$ipadm_name\" for \"$ipadm_property\" is \"$correct_value\""
      fi
      if [ "$current_value" -ne "$correct_value" ]; then
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score - 1`
          echo "Warning:   Value of \"$ipadm_name $ipadm_property\" not set to \"$correct_value\" [$score]"
        else
          if [ "$audit_mode" = 0 ]; then
            echo "Setting:   Value of \"$ipadm_name $ipadm_property\" to \"$correct_value\""
            echo "$ipadm_name,$ipadm_property,$correct_value" >> $log_file
            ipadm set-prop -p $ipadm_name=$correct_value $ipadm_property
          fi
        fi
      else
        if [ "$audit_mode" != 2 ]; then
          if [ "$audit_mode" = 1 ]; then
            score=`expr $score + 1`
            echo "Secure:    Value of \"$ipadm_name $ipadm_property\" already set to \"$correct_value\" [$score]"
          fi
        fi
      fi
    fi
  fi
}

# Disable Network Routing
# Disable Source Packet Forwarding
# Disable Directed Broadcast Packet Forwarding
# Disable Response to ICMP Timestamp Requests
# Disable Response to ICMP Broadcast Timestamp Requests
# Disable Response to ICMP Broadcast Netmask Requests
# Disable Response to Broadcast ICMPv4 Echo Request
# Disable Response to Multicast Echo Request
# Ignore ICMP Redirect Messages
# Set Strict Multihoming
# Disable ICMP Redirect Messages
# Disable TCP Reverse IP Source Routing
# Set Maximum Number of Half-open TCP Connections
# Set Maximum Number of Incoming Connections

audit_routing_params () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      audit_command_value routeadm ipv4-routing disabled
      audit_command_value routeadm ipv6-routing disabled
      audit_command_value routeadm ipv4-forwarding disabled
      audit_command_value routeadm ipv6-forwarding disabled
      funct_file_exists /etc/notrouter yes
    fi
    if [ "$os_version" = "11" ]; then
      audit_ipadm_value _forward_src_routed ipv4 0
      audit_ipadm_value _forward_src_routed ipv6 0
      audit_ipadm_value _forward_directed_broadcasts ip 0
      audit_ipadm_value _respond_to_timestamp ip 0
      audit_ipadm_value _respond_to_timestamp_broadcast ip 0
      audit_ipadm_value _respond_to_address_mask_broadcast ip 0
      audit_ipadm_value _respond_to_echo_broadcast ip 0
      audit_ipadm_value _respond_to_echo_multicast ipv4 0
      audit_ipadm_value _respond_to_echo_multicast ipv6 0
      audit_ipadm_value _ignore_redirect ipv4 1
      audit_ipadm_value _ignore_redirect ipv6 1
      audit_ipadm_value _strict_dst_multihoming ipv4 1
      audit_ipadm_value _strict_dst_multihoming ipv6 1
      audit_ipadm_value _send_redirects ipv4 0
      audit_ipadm_value _send_redirects ipv6 0
      audit_ipadm_value _rev_src_routes tcp 0
      audit_ipadm_value _conn_req_max_q0 tcp 4096
      audit_ipadm_value _conn_req_max_q tcp 1024
    fi
  fi
}

# Create An Audit Class

audit_create_class () {
  if [ "$os_name" = "SunOS" ]; then
    check_file="/etc/security/audit_class"
    class_check=`cat $check_file |grep "Security Lockdown"`
    total=`expr $total + 1`
    if [ `expr "$class_check" : "[A-z]"` != 1 ]; then
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score - 1`
        echo "Warning:   Audit class not enabled [$score]"
      else
        if [ "$audit_mode" = 0 ]; then
          echo "Setting:   Audit class to enabled"
          if [ ! -f "$work_dir$check_file" ]; then
            echo "Saving:    File $check_file to $work_dir$check_file"
            find $check_file | cpio -pdm $work_dir 2> /dev/null
          fi
          file_length=`wc -l $check_file |awk '{print $1}' |sed 's/ //g'`
          file_length=`expr $file_length - 1`
          head -$file_length $check_file > $temp_file
          echo "0x0100000000000000:lck:Security Lockdown" >> $temp_file
          tail -1 $check_file >> $temp_file
          cp $temp_file $check_file
        fi
      fi
    fi
    if [ "$audit_mode" = 2 ]; then
      if [ -f "$restore_dir/$check_file" ]; then
        cp -p $restore_dir/$check_file $check_file
        if [ "$os_version" = "10" ]; then
          pkgchk -f -n -p $check_file 2> /dev/null
        else
          pkg fix `pkg search $check_file |grep pkg |awk '{print $4}'`
        fi
      fi
    fi
  fi
}

# Enable Auditing of Incoming Network Connections

audit_network_connections () {
  if [ "$os_name" = "SunOS" ]; then
    funct_append_file $check_file "lck:AUE_ACCEPT" hash
    funct_append_file $check_file "lck:AUE_CONNECT" hash
    funct_append_file $check_file "lck:AUE_SOCKACCEPT" hash
    funct_append_file $check_file "lck:AUE_SOCKCONNECT" hash
    funct_append_file $check_file "lck:AUE_inetd_connect" hash
  fi
}

# Enable Auditing of File Metadata Modification Events

audit_file_metadata () {
  funct_append_file $check_file "lck:AUE_CHMOD" hash
  funct_append_file $check_file "lck:AUE_CHOWN" hash
  funct_append_file $check_file "lck:AUE_FCHOWN" hash
  funct_append_file $check_file "lck:AUE_FCHMOD" hash
  funct_append_file $check_file "lck:AUE_LCHOWN" hash
  funct_append_file $check_file "lck:AUE_ACLSET" hash
  funct_append_file $check_file "lck:AUE_FACLSET" hash
}

# Enable Auditing of Process and Privilege Events

audit_privilege_events () {
  funct_append_file $check_file "lck:AUE_CHROOT" hash
  funct_append_file $check_file "lck:AUE_SETREUID" hash
  funct_append_file $check_file "lck:AUE_SETREGID" hash
  funct_append_file $check_file "lck:AUE_FCHROOT" hash
  funct_append_file $check_file "lck:AUE_PFEXEC" hash
  funct_append_file $check_file "lck:AUE_SETUID" hash
  funct_append_file $check_file "lck:AUE_NICE" hash
  funct_append_file $check_file "lck:AUE_SETGID" hash
  funct_append_file $check_file "lck:AUE_PRIOCNTLSYS" hash
  funct_append_file $check_file "lck:AUE_SETEGID" hash
  funct_append_file $check_file "lck:AUE_SETEUID" hash
  funct_append_file $check_file "lck:AUE_SETPPRIV" hash
  funct_append_file $check_file "lck:AUE_SETSID" hash
  funct_append_file $check_file "lck:AUE_SETPGID" hash
}

# Create audit class on Solaris 11
# Need to investigate more auditing capabilities on Solaris 10

audit_audit_class () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "11" ]; then
      audit_create_class
      audit_network_connections
      audit_file_metadata
      audit_privilege_events
    fi
  fi
}

audit_command_output () {
  if [ "$os_name" = "SunOS" ]; then
    command_name=$1
    total=`expr $total + 1`
    if [ "$command_name" = "getcond" ]; then
      get_command="auditconfig -getcond |cut -f2 -d'=' |sed 's/ //g'"
    fi
    if [ "$command_name" = "getpolicy" ]; then
      get_command="auditconfig -getpolicy |head -1 |cut -f2 -d'=' |sed 's/ //g'"
      correct_value="argv,cnt,zonename"
      restore_command="auditconfig -setpolicy"
    fi
    if [ "$command_name" = "getnaflages" ]; then
      get_command="auditconfig -getpolicy |head -1 |cut -f2 -d'=' |sed 's/ //g' |cut -f1 -d'('"
      correct_value="lo"
      restore_command="auditconfig -setnaflags"
    fi
    if [ "$command_name" = "getflages" ]; then
      get_command="auditconfig -getflags |head -1 |cut -f2 -d'=' |sed 's/ //g' |cut -f1 -d'('"
      correct_value="lck,ex,aa,ua,as,ss,lo,ft"
      restore_command="auditconfig -setflags"
    fi
    if [ "$command_name" = "getplugin" ]; then
      get_command="auditconfig -getplugin audit_binfile |tail-1 |cut -f3 -d';'"
      correct_value="p_minfree=1"
      restore_command="auditconfig -setplugin audit_binfile active"
    fi
    if [ "$command_name" = "userattr" ]; then
      get_command="userattr audit_flags root"
      correct_value="lo,ad,ft,ex,lck:no"
      restore_command="auditconfig -setplugin audit_binfile active"
    fi
    if [ "$command_name" = "getcond" ]; then
      set_command="auditconfig -conf"
    else
      if [ "$command_name" = "getflags" ]; then
        set_command="$restore_command lo,ad,ft,ex,lck"
      else
        set_command="$restore_command $correct_value"
      fi
    fi
    log_file="$command_name.log"
    check_value=`$get_command`
    if [ "$audit_mode" = 1 ]; then
      if [ "$check_value" != "$correct_value" ]; then
        score=`expr $score - 1`
        echo "Warning:   Command $command_name does not return correct value [$score]"
      else
        score=`expr $score + 1`
        echo "Secure:    Command $command_name returns correct value [$score]"
      fi
    fi
    if [ "$audit_mode" = 0 ]; then
      log_file="$work_dir/$log_file"
      if [ "$check_value" != "$test_value" ]; then
        echo "Setting:   Command $command_name to correct value"
        $test_command > $log_file
        $set_command
      fi
    fi
    if [ "$audit_mode" = 2 ]; then
      restore_file="$restore_dir/$log_file"
      if [ -f "$restore_file" ]; then
        echo "Restoring: Previous value for $command_name"
        if [ "$command_name" = "getcond" ]; then
          $restore_command
        else
          restore_string=`cat $restore_file`
          $restore_command $restore_string
        fi
      fi
    fi
  fi
}

# Configure Solaris Auditing

# Check auditing setup on Solaris 11
# Need to investigate more auditing capabilities on Solaris 10

audit_solaris_auditing () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "11" ]; then
      audit_command_output getcond
      audit_command_output getpolicy
      audit_command_output getnaflags
      audit_command_output getplugin
      audit_command_output userattr
      if [ "$audit_mode" != 1 ]; then
        audit -s
      fi
      check_file="/var/spool/cron/crontabs/root"
      if [ "$audit_mode" = 0 ]; then
        log_file="$workdir$check_file"
        rolemod -K audit_flags=lo,ad,ft,ex,lck:no root
        audit_check=`cat $check_file |grep "audit -n" |cut -f4 -d'/'`
        if [ "$audit_check" != "audit -n" ]; then
          if [ ! -f "$log_file" ]; then
            echo "Saving:    File $check_file to $work_dir$check_file"
            find $check_file | cpio -pdm $work_dir 2> /dev/null
          fi
          echo "0 * * * * /usr/sbin/audit -n" >> $check_file
          chown root:root /var/audit 
          chmod 750 /var/audit
          pkg fix `pkg search $check_file |grep pkg |awk '{print $4}'`
        fi
      fi
    fi
  fi
}

# Audit cron perms

audit_cron_perms () {
  if [ "$os_name" = "Linux" ]; then
    check_file="/etc/crontab"
    audit_check_perms $check_file 0640 root root
    check_file="/var/spool/cron"
    audit_check_perms $check_file 0750 root root
    check_file="/etc/cron.daily"
    audit_check_perms $check_file 0750 root root
    check_file="/etc/cron.weekly"
    audit_check_perms $check_file 0750 root root
    check_file="/etc/cron.mounthly"
    audit_check_perms $check_file 0750 root root
    check_file="/etc/cron.hourly"
    audit_check_perms $check_file 0750 root root
    check_file="/etc/anacrontab"
    audit_check_perms $check_file 0750 root root
  fi
}

# Enable inetd Connection Logging

audit_inetd_logging () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      audit_command_value inetadm tcp_trace TRUE tcp
    fi
    if [ "$os_version" = "9" ]; then
      check_file="/etc/default/inetd"
      audit_file_value $check_file ENABLE_CONNECTION_LOGGING eq YES hash
    fi
  fi
}

# Enable FTP daemon Logging

audit_ftp_logging () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      get_command="svcprop -p inetd_start/exec svc:/network/ftp:default"
      check_value=`$get_command |grep "\-d" | wc -l`
      file_header="ftpd_logging"
      if [ "$audit_mode" != 2 ]; then
        echo "Checking:  File $file_header"
      fi
      log_file="$work_dir/$file_header.log"
      total=`expr $total + 1`
      if [ "$audit_mode" = 1 ]; then
        if [ "$check_value" -eq 0 ]; then
          score=`expr $score - 1`
          echo "Warning:   FTP daemon logging not enabled [$score]"
        else
          score=`expr $score + 1`
          echo "Secure:    FTP daemon logging enabled [$score]"
        fi
      else
        if [ "$audit_mode" = 0 ]; then
          if [ "$check_value" -eq 0 ]; then
            echo "Setting:   FTP daemon logging to enabled"
            $get_command > $log_file
            inetadm -m svc:/network/ftp exec="/usr/sbin/in.ftpd -a -l -d"
          fi
        else
          if [ "$audit_mode" = 2 ]; then
            restore_file="$restore_dir/$file_header.log"
            if [ -f "$restore_file" ]; then
              exec_string=`cat $restore_file`
              echo "Restoring: Previous value for FTP daemon to $exec_string"
              inetadm -m svc:/network/ftp exec="$exec_string"
            fi
          fi
        fi
      fi
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    check_file="/etc/vsftpd.conf"
    if [ -f "$check_file" ]; then
      audit_file_value $check_file log_ftp_protocol eq YES hash
      audit_file_value $check_file ftpd_banner eq "Authorized users only. All activity may be monitored and reported." hash
      audit_check_perms $check_file 0600 root root
    fi
    check_file="/etc/vsftpd/vsftpd.conf"
    if [ -f "$check_file" ]; then
      audit_file_value $check_file log_ftp_protocol eq YES hash
      audit_file_value $check_file ftpd_banner eq "Authorized users only. All activity may be monitored and reported." hash
      audit_check_perms $check_file 0600 root root
    fi
  fi
}

# Audit syslog.conf

audit_syslog_conf () {
  if [ "$os_name" = "Linux" ]; then
    check_file="/etc/syslog.conf"
    audit_file_value $check_file "authpriv.*" tab "/var/log/secure" hash
    audit_file_value $check_file "auth.*" tab "/var/log/messages" hash
  fi
}

# Enable Debug Level Daemon Logging

audit_logadm_value () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      log_name=$1
      log_facility=$2
      check_file="/etc/logadm.conf"
      check_log=`logadm -V |grep -v '^#' |grep "$log_name"`
      log_file="/var/log/$log_name"
      total=`expr $total + 1`
      if [ `expr "$check_log" : "[A-z]"` != 1 ]; then
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score - 1`
          echo "Warning:   Logging for $log_name not enabled [$score]"
        else
          if [ "$audit_mode" = 0 ]; then
            echo "Setting:   Syslog to capture $log_facility"
          fi
          funct_backup_file $check_file
          if [ "$log_facility" != "none" ]; then
            check_file="/etc/syslog.conf"
            if [ ! -f "$work_dir$check_file" ]; then
              echo "Saving:    File $check_file to $work_dir$check_file"
              find $check_file | cpio -pdm $work_dir 2> /dev/null
            fi
          fi
          echo "$log_facility\t\t\t$log_file" >> $check_file
          touch $log_file
          chown root:root $log_file
          if [ "$log_facility" = "none" ]; then
            logadm -w $log_name -C 13 $log_file
          else
            logadm -w $log_name -C 13 -a 'pkill -HUP syslogd' $log_file
            svcadm refresh svc:/system/system-log
          fi
        fi
        if [ "$audit_mode" = 2 ]; then
          if [ -f "$restore_dir/$check_file" ]; then
            cp -p $restore_dir/$check_file $check_file
            if [ "$os_version" != "11" ]; then
              pkgchk -f -n -p $check_file 2> /dev/null
            else
              pkg fix `pkg search $check_file |grep pkg |awk '{print $4}'`
            fi
          fi
          if [ "$log_facility" = "none" ]; then
            check_file="/etc/syslog.conf"
            if [ -f "$restore_dir/$check_file" ]; then
              cp -p $restore_dir/$check_file $check_file
              if [ "$os_version" != "11" ]; then
                pkgchk -f -n -p $check_file 2> /dev/null
              else
                pkg fix `pkg search $check_file |grep pkg |awk '{print $4}'`
              fi
            fi
            svcadm refresh svc:/system/system-log
          fi
        fi
      else
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score + 1`
          echo "Secure:    Logging for $log_name already enabled [$score]"
        fi
      fi
    fi
  fi
}

# Enable connection logging

audit_debug_logging () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      audit_logadm_value connlog daemon.debug
    fi
  fi
}

# Capture syslog AUTH Messages

audit_syslog_auth () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      audit_logadm_value authlog auth.info
    fi
  fi
}

# Enable Login Records

audit_login_records () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      audit_logadm_value loginlog none
    fi
  fi
}

# Capture All Failed Login Attempts

audit_failed_logins () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      check_file="/etc/default/login"
      audit_file_value $check_file SYSLOG_FAILED_LOGINS eq 0 hash
    fi
  fi
}

# Enable cron Logging

audit_cron_logging () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      check_file="/etc/default/cron"
      audit_file_value $check_file CRONLOG eq YES hash
      if [ "$audit_mode" = 0 ]; then
        chown root:root /var/cron/log
        chmod go-rwx /var/cron/log
      fi
    fi
  fi
}

# Linux restore service

# Check package
# Takes the following variables:
# package_mode:   Mode, eg check install uninstall restore
# package_check:  Package to check for
# restore_file:   Restore file to check 

audit_linux_package () {
  if [ "$os_name" = "Linux" ]; then
    package_mode=$1
    package_check=$2
    restore_file=$3
    if [ "$os_name" = "Linux" ]; then
      if [ "$package_mode" = "check" ]; then
        package_name=`rpm -qi $package_check |grep '^Name' |awk '{print $3}'`
      fi
      if [ "$package_mode" = "install" ]; then
        yum -y install $package_check
      fi
      if [ "$package_mode" = "uninstall" ]; then
        rpm -e $package_check
      fi
      if [ "$package_mode" = "restore" ]; then
        if [ -f "$restore_file" ]; then
          restore_check=`cat $restore_file |grep $package_check |awk '{print $2}'`
          if [ "$restore_check" = "$package_check" ]; then
            package_action=`cat $restore_file |grep $package_check |awk '{print $1}'`
            echo "Restoring: Package $package_action to $package_action"
            if [ "$package_action" = "Installed" ]; then
              rpm -e $package_check
            else
              yum -y install $package_check
            fi
          fi
        fi
      fi
    fi
  fi
}

# Enable System Accounting

audit_system_accounting () {
  if [ "$os_name" = "Linux" ]; then
    total=`expr $total + 1`
    log_file="sysstat.log"
    audit_linux_package check sysstat
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  System accounting is enabled"
    fi
    if [ "$package_name" != "sysstat" ]; then
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score - 1`
        echo "Warning:   System accounting not enabled [$score]"
      fi
      if [ "$audit_mode" = 0 ]; then
        echo "Setting:   System Accounting to enabled"
        log_file="$work_dir/$log_file"
        echo "Installed sysstat" >> $log_file
        audit_linux_package install sysstat
      fi
    else
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score + 1`
        echo "Secure:    System accounting enabled [$score]"
      fi
      if [ "$audit_mode" = 2 ]; then
        restore_file="$restore_dir/$log_file"
        audit_linux_package restore sysstat $restore_file
      fi
    fi
    check_file="/etc/audit/audit.rules"
    # Set failure mode to syslog notice
    funct_append_file $check_file "## Things that could affect time" hash
    funct_append_file $check_file "-f 1" hash
    funct_append_file $check_file "-a always,exit -F arch=b32 -S adjtimex -S settimeofday -S stime -k time-change" hash
    if [ "$os_platform" = "x86_64" ]; then
      funct_append_file $check_file "-a always,exit -F arch=b64 -S adjtimex -S settimeofday -k time-change" hash
    fi
    funct_append_file $check_file "-a always,exit -F arch=b32 -S clock_settime -k time-change" hash
    if [ "$os_platform" = "x86_64" ]; then
      funct_append_file $check_file "-a always,exit -F arch=b64 -S clock_settime -k time-change" hash
    fi
    funct_append_file $check_file "-w /etc/localtime -p wa -k time-change" hash
    # Things that affect identity
    funct_append_file $check_file "-w /etc/group -p wa -k identity" hash
    funct_append_file $check_file "-w /etc/passwd -p wa -k identity" hash
    funct_append_file $check_file "-w /etc/gshadow -p wa -k identity" hash
    funct_append_file $check_file "-w /etc/shadow -p wa -k identity" hash
    funct_append_file $check_file "-w /etc/security/opasswd -p wa -k identity" hash
    # Things that could affect system locale
    funct_append_file $check_file "-a exit,always -F arch=b32 -S sethostname -S setdomainname -k system-locale" hash
    if [ "$os_platform" = "x86_64" ]; then
      funct_append_file $check_file "-a exit,always -F arch=b64 -S sethostname -S setdomainname -k system-locale" hash
    fi
    funct_append_file $check_file "-w /etc/issue -p wa -k system-locale" hash
    funct_append_file $check_file "-w /etc/issue.net -p wa -k system-locale" hash
    funct_append_file $check_file "-w /etc/hosts -p wa -k system-locale" hash
    funct_append_file $check_file "-w /etc/sysconfig/network -p wa -k system-locale" hash
    # Things that could affect MAC policy
    funct_append_file $check_file "-w /etc/selinux/ -p wa -k MAC-policy" hash
    # Things that could affect logins
    funct_append_file $check_file "-w /var/log/faillog -p wa -k logins" hash
    funct_append_file $check_file "-w /var/log/lastlog -p wa -k logins" hash
    #- Process and session initiation (unsuccessful and successful)
    funct_append_file $check_file "-w /var/run/utmp -p wa -k session" hash
    funct_append_file $check_file "-w /var/log/btmp -p wa -k session" hash
    funct_append_file $check_file "-w /var/log/wtmp -p wa -k session" hash
    #- Discretionary access control permission modification (unsuccessful and successful use of chown/chmod)
    funct_append_file $check_file "-a always,exit -F arch=b32 -S chmod -S fchmod -S fchmodat -F auid>=500 -F auid!=4294967295 -k perm_mod" hash
    if [ "$os_platform" = "x86_64" ]; then
      funct_append_file $check_file "-a always,exit -F arch=b64 -S chmod -S fchmod -S fchmodat -F auid>=500 -F auid!=4294967295 -k perm_mod" hash
    fi
    funct_append_file $check_file "-a always,exit -F arch=b32 -S chown -S fchown -S fchownat -S lchown -F auid>=500 - F auid!=4294967295 -k perm_mod" hash
    if [ "$os_platform" = "x86_64" ]; then
      funct_append_file $check_file "-a always,exit -F arch=b64 -S chown -S fchown -S fchownat -S lchown -F auid>=500 - F auid!=4294967295 -k perm_mod" hash
    fi
    funct_append_file $check_file "-a always,exit -F arch=b32 -S setxattr -S lsetxattr -S fsetxattr -S removexattr -S lremovexattr -S fremovexattr -F auid>=500 -F auid!=4294967295 -k perm_mod" hash
    if [ "$os_platform" = "x86_64" ]; then
      funct_append_file $check_file "-a always,exit -F arch=b64 -S setxattr -S lsetxattr -S fsetxattr -S removexattr -S lremovexattr -S fremovexattr -F auid>=500 -F auid!=4294967295 -k perm_mod" hash
    fi
    #- Unauthorized access attempts to files (unsuccessful)
    funct_append_file $check_file "-a always,exit -F arch=b32 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EACCES -F auid>=500 -F auid!=4294967295 -k access" hash
    funct_append_file $check_file "-a always,exit -F arch=b32 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EPERM -F auid>=500 -F auid!=4294967295 -k access" hash
    if [ "$os_platform" = "x86_64" ]; then
      funct_append_file $check_file "-a always,exit -F arch=b64 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EACCES -F auid>=500 -F auid!=4294967295 -k access" hash
      funct_append_file $check_file "-a always,exit -F arch=b64 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EPERM -F auid>=500 -F auid!=4294967295 -k access" hash
    fi
    #- Use of privileged commands (unsuccessful and successful)
    #funct_append_file $check_file "-a always,exit -F path=/bin/ping -F perm=x -F auid>=500 -F auid!=4294967295 -k privileged" hash
    funct_append_file $check_file "-a always,exit -F arch=b32 -S mount -F auid>=500 -F auid!=4294967295 -k export" hash
    if [ "$os_platform" = "x86_64" ]; then
      funct_append_file $check_file "-a always,exit -F arch=b64 -S mount -F auid>=500 -F auid!=4294967295 -k export" hash
    fi
    #- Files and programs deleted by the user (successful and unsuccessful)
    funct_append_file $check_file "-a always,exit -F arch=b32 -S unlink -S unlinkat -S rename -S renameat -F auid>=500 -F auid!=4294967295 -k delete" hash
    if [ "$os_platform" = "x86_64" ]; then
      funct_append_file $check_file "-a always,exit -F arch=b64 -S unlink -S unlinkat -S rename -S renameat -F auid>=500 -F auid!=4294967295 -k delete" hash
    fi
    #- All system administration actions
    funct_append_file $check_file "-w /etc/sudoers -p wa -k scope" hash
    funct_append_file $check_file "-w /etc/sudoers -p wa -k actions" hash
    #- Make sue kernel module loading and unloading is recorded
    funct_append_file $check_file "-w /sbin/insmod -p x -k modules" hash
    funct_append_file $check_file "-w /sbin/rmmod -p x -k modules" hash
    funct_append_file $check_file "-w /sbin/modprobe -p x -k modules" hash
    funct_append_file $check_file "-a always,exit -S init_module -S delete_module -k modules" hash
    #- Tracks successful and unsuccessful mount commands
    if [ "$os_platform" = "x86_64" ]; then
      funct_append_file $check_file "-a always,exit -F arch=b64 -S mount -F auid>=500 -F auid!=4294967295 -k mounts" hash
    fi
    funct_append_file $check_file "-a always,exit -F arch=b32 -S mount -F auid>=500 -F auid!=4294967295 -k mounts" hash
    #funct_append_file $check_file "" hash
    #funct_append_file $check_file "" hash
    funct_append_file $check_file "" hash
    #- Manage and retain logs
    funct_append_file $check_file "space_left_action = email" hash
    funct_append_file $check_file "action_mail_acct = email" hash
    funct_append_file $check_file "admin_space_left_action = email" hash
    #funct_append_file $check_file "" hash
    funct_append_file $check_file "max_log_file = MB" hash
    funct_append_file $check_file "max_log_file_action = keep_logs" hash
    #- Make file immutable - MUST BE LAST!
    funct_append_file $check_file "-e 2" hash
    service_name="sysstat"
    audit_chkconfig_service $service_name 3 off
    audit_chkconfig_service $service_name 5 off
    service_bname="auditd"
    audit_chkconfig_service $service_name 3 off
    audit_chkconfig_service $service_name 5 off
  fi
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      cron_file="/var/spool/cron/crontabs/sys"
      sar_check=`cat $check_file |grep -v "^#" |grep "sa2"`
      total=`expr $total + 1`
      if [ `expr "$sar_check" : "[A-z]"` != 1 ]; then
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score - 1`
          echo "Warning:   System Accounting is not enabled [$score]"
        fi
        if [ "$audit_mode" = 0 ]; then
          echo "Setting:   System Accounting to enabled"
          if [ ! -f "$log_file" ]; then
            echo "Saving:    File $check_file to $work_dir$check_file"
            find $check_file | cpio -pdm $work_dir 2> /dev/null
          fi
          echo "0,20,40 * * * * /usr/lib/sa/sa1" >> $check_file
          echo "45 23 * * * /usr/lib/sa/sa2 -s 0:00 -e 23:59 -i 1200 -A" >> $check_file
          chown sys:sys /var/adm/sa/* 
          chmod go-wx /var/adm/sa/*
          if [ "$os_version" = "10" ]; then
            pkgchk -f -n -p $check_file 2> /dev/null
          else
            pkg fix `pkg search $check_file |grep pkg |awk '{print $4}'`
          fi
        fi
      else
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score + 1`
          echo "Secure:    System Accounting is already enabled [$score]"
        fi
        if [ "$audit_mode" = 2 ]; then
          funct_restore_file $check_file $restore_dir
        fi
      fi
    fi
  fi
}

# Enable Kernel Level Auditing

audit_kernel_accounting () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      check_file="/etc/system"
      check_acc=`cat $check_file |grep -v '^*' |grep 'c2audit:audit_load'`
      if [ `expr "$check_acc" : "[A-z]"` != 1 ]; then
        audit_file_value $check_file c2audit colon audit_load star
        if [ "$audit_mode" = 0 ]; then
          log_file="$work_dir/bsmconv.log"
          echo "y" >> $log_file
          echo "y" | /etc/security/bsmconv
        fi
      fi
      if [ "$audit_mode" = 2 ]; then
        restore_file="$restore_dir/bsmconv.log"
        if [ -f "$restore_file" ]; then
          echo "y" | /etc/security/bsmunconv
        fi
      fi
      check_file="/etc/security/audit_control"
      audit_file_value $check_file flags colon "lo,ad,cc" hash
      audit_file_value $check_file naflags colon "lo,ad,ex" hash
      audit_file_value $check_file minfree colon 20 hash
      check_file="/etc/security/audit_user"
      audit_file_value $check_file root colon "lo,ad:no" hash
    fi
  fi
}

# Set daemon umask
# Default Service File Creation Mask

audit_daemon_umask () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "11" ]; then
      umask_check=`svcprop -p umask/umask svc:/system/environment:init`
      umask_value="022"
      log_file="umask.log"
      total=`expr $total + 1`
      if [ "$umask_check" != "$umask_value" ]; then
        log_file="$work_dir/$log_file"
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score - 1`
          echo "Warning:   Default service file creation mask not set to $umask_value [$score]"
        fi
        if [ "$audit_mode" = 0 ]; then
          echo "Setting:   Default service file creation mask to $umask_value"
          if [ ! -f "$log_file" ]; then
            echo "$umask_check" >> $log_file
          fi
          svccfg -s svc:/system/environment:init setprop umask/umask = astring:  "$umask_value"
        fi
      else
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score + 1`
          echo "Secure:    Default service file creation mask set to $umask_value [$score]"
        fi
        if [ "$audit_mode" = 2 ]; then
          restore_file="$restore_dir/$log_file"
          if [ -f "$restore_file" ]; then
            restore_value=`cat $restore_file`
            if [ "$restore_value" != "$umask_check" ]; then
              echo "Restoring:  Default service file creation mask to $restore_vaule"
              svccfg -s svc:/system/environment:init setprop umask/umask = astring:  "$restore_value"
            fi
          fi
        fi
      fi
    else
      if [ "$os_version" = "7" ] || [ "$os_version" = "6" ]; then
        check_file="/etc/init.d/umask.sh"
        audit_file_value $check_file umask space 022 hash
        if [ "$audit_mode" = "0" ]; then
          if [ -f "$check_file" ]; then
            audit_check_perms $check_file 0744 root sys
            for dir_name in /etc/rc?.d; do
              link_file="$dir_name/S00umask"
              if [ ! -f "$link_file" ]; then
                ln -s $check_file $link_file
              fi
            done
          fi
        fi
      else
        check_file="/etc/default/init"
        audit_file_value $check_file CMASK eq 022 hash
      fi
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    check_file="/etc/sysconfig/init"
    audit_file_value $check_file umask space 027 hash
    if [ "$audit_mode" = "0" ]; then
      if [ -f "$check_file" ]; then
        audit_check_perms $check_file 0755 root root
      fi
    fi
  fi
}

# Restrict Set-UID on User Mounted Devices
# Set nodev on filesystems

audit_mount_setuid () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      check_file="/etc/rmmount.conf"
      nosuid_check=`cat $check_file |grep -v "^#" |grep "\-o nosuid"`
      log_file="$work_dir/$check_file"
      total=`expr $total + 1`
      if [ `expr "$nosuid_check" : "[A-z]"` != 1 ]; then
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score - 1`
          echo "Warning:   Set-UID not restricted on user mounted devices [$score]"
        fi
        if [ "$audit_mode" = 0 ]; then
          echo "Setting:   Set-UID restricted on user mounted devices"
          funct_backup_file $check_file
          funct_append_file $check_file "mount * hsfs udfs ufs -o nosuid" hash
        fi
      else
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score + 1`
          echo "Secure:    Set-UID not restricted on user mounted devices [$score]"
        fi
        if [ "$audit_mode" = 2 ]; then
          funct_restore_file $check_file $restore_dir
        fi
      fi
    fi
  fi
}

# Look for unconfined daemons

audit_unconfined_daemons () {
  if [ "$os_name" = "Linux" ]; then
    daemon_check=`ps -eZ | egrep "initrc" | egrep -vw "tr|ps|egrep|bash|awk" | tr ':' ' ' | awk '{ print $NF }'`
    total=`expr $total + 1`
    if [ "$daemon_check" = "" ]; then
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score - 1`
        echo "Warning:   Unconfined daemons $daemon_check [$score]"
      fi
    else
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score + 1`
        echo "Secure:    No unconfined daemons [$score]"
      fi
    fi
  fi
}

# Check single user mode requires password

audit_sulogin () {
  if [ "$os_name" = "Linux" ]; then
    check_file="/etc/inittab"
    sulogin_check=`grep -l sulogin $check_file`
    total=`expr $total + 1`
    if [ "$sulogin_check" = "" ]; then
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score - 1`
        echo "Warning:   No Authentication required for single usermode [$score]"
      fi
      if [ "$audit_mode" = 0 ]; then
        echo "Setting:   Single user mode to require authentication"
        funct_backup_file $check_file
        cat $check_file |awk '{ print }; /^id:[0123456sS]:initdefault:/ { print "~~:S:wait:/sbin/sulogin" }' > $temp_file
        cat $temp_file > $check_file
        rm $temp_file
      fi
    else
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score + 1`
        echo "Secure:    Single usermode requires authentication [$score]"
      fi
      if [ "$audit_mode" = 2 ]; then
        funct_restore_file $check_file $restore_dir
      fi
      audit_check_perms $check_file 0600 root root
    fi
    check_file="/etc/sysconfig/init"
    audit_file_value $check_file SINGLE eq "/sbin/sulogin" hash
    audit_file_value $check_file PROMPT eq no hash
  fi
}

# Check filesystems are mounted with nodev

audit_mount_nodev () {  
  if [ "$os_name" = "Linux" ]; then
    check_file="/etc/fstab"
    if [ "$audit_mode" != "2" ]; then
      nodev_check=`cat $check_file |grep -v "^#" |egrep "ext2|ext3" |grep -v '/ ' |grep -v '/boot' |head -1 |wc -l`
      total=`expr $total + 1`
      if [ "$nodev_check" = 1 ]; then
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score - 1`
          echo "Warning:   Found filesystems that should be mounted nodev [$score]"
        fi
        if [ "$audit_mode" = 0 ]; then
          echo "Setting:   Setting nodev on filesystems"
          funct_backup_file $check_file
          cat $check_file | awk '( $3 ~ /^ext[23]$/ && $2 != "/" ) { $4 = $4 ",nodev" }; { printf "%-26s %-22s %-8s %-16s %-1s %-1s\n",$1,$2,$3,$4,$5,$6 }' > $temp_file
          cat $temp_file > $check_file
          rm $temp_file
        fi
      else
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score + 1`
          echo "Secure:    No filesystem that should be mounted with nodev [$score]"
        fi
        if [ "$audit_mode" = 2 ]; then
          funct_restore_file $check_file $restore_dir
        fi
      fi
    fi
    audit_check_perms $check_file 0644 root root
  fi
}

audit_mount_fdi () {
  if [ "$os_name" = "Linux" ]; then
    check_dir="/usr/share/hal/fdi/95userpolicy"
    if [ -e "$check_dir" ]; then
      check_file="$check_dir/floppycdrom.fdi"
    else
      check_dir="/usr/share/hal/fdi/policy/20thirdparty"
      check_file="$check_dir/floppycdrom.fdi"
    fi
    if [ ! -f "$check_file" ]; then
      touch $check_file
      chmod 640 $check_file
      chown root:root $check_file
    fi
    if [ "$audit_mode" != "2" ]; then
      fdi_check=`cat $check_file |grep -v "Default policies" |head -1 |wc -l`
      total=`expr $total + 1`
      if [ "$fdi_check" = 1 ]; then
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score - 1`
          echo "Warning:   User mountable filesystems enabled [$score]"
        fi
        if [ "$audit_mode" = 0 ]; then
          echo "Setting:   Disabling user mountable filesystems"
          funct_backup_file $check_file
          echo '<?xml version="1.0" encoding="ISO-8859-1"?> <!-- -*- SGML -*- --> >' > $temp_file
          echo '<deviceinfo version="0.2">' >> $temp_file
          echo '  <!-- Default policies merged onto computer root object -->' >> $temp_file
          echo '  <device>' >> $temp_file
          echo '    <match key="info.udi" string="/org/freedesktop/Hal/devices/computer">' >> $temp_file
          echo '      <merge key="storage.policy.default.mount_option.nodev" type="bool">true</merge>' >> $temp_file
          echo '      <merge key="storage.policy.default.mount_option.nosuid" type="bool">true</merge>' >> $temp_file
          echo '    </match>' >> $temp_file
          echo '  </device>' >> $temp_file
          echo '</deviceinfo>' >> $temp_file
          cat $temp_file > $check_file
          rm $temp_file
        fi
      else
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score + 1`
          echo "Secure:    User mountable filesystems disabled [$score]"
        fi
        if [ "$audit_mode" = 2 ]; then
          funct_restore_file $check_file $restore_dir
        fi
      fi
    fi
    audit_check_perms $check_file 0640 root root
  fi
}

# Set Sticky Bit on World Writable Directories

audit_sticky_bit () {
  total=`expr $total + 1`
  if [ "$os_version" = "10" ]; then
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  Sticky bits set on world writable directories [This may take a while]"
    fi
    log_file="$work_dir/sticky_bits"
    for check_dir in `find / \( -fstype nfs -o -fstype cachefs \
      -o -fstype autofs -o -fstype ctfs \
      -o -fstype mntfs -o -fstype objfs \
      -o -fstype proc \) -prune -o -type d \
      \( -perm -0002 -a ! -perm -1000 \) -print`; do
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score - 1`
        echo "Warning:   Sticky bit not set on $check_dir [$score]"
      fi
      if [ "$audit_mode" = 0 ]; then
        echo "Setting:   Sticky bit on $check_dir"
        chmod +t $check_dir
        echo "$check_dir" >> $log_file
      fi
    done
    if [ "$audit_mode" = 2 ]; then
      restore_file="$restore_dir/sticky_bits"
      if [ -f "$restore_file" ]; then
        for check_dir in `cat $restore_file`; do
          if [ -d "$check_dir" ]; then
            echo "Restoring:  Removing sticky bit from $check_dir"
            chmod -t $check_dir
          fi
        done
      fi
    fi
  fi
}

# Audit selinux

audit_selinux () {
  if [ "$os_name" = "Linux" ]; then
    check_file="/etc/selinux/config"
    audit_file_value $check_file SELINUX eq enforcing hash
    audit_file_value $check_file SELINUXTYPE eq targeted hash
  fi
}

# Audit yum configuration

audit_yum_conf () {
  if [ "$os_name" = "Linux" ]; then
    check_file="/etc/yum.conf"
    audit_file_value $check_file gpgcheck eq 1 hash
  fi
}

# Configure SSH
# Set SSH Protocol to 2
# Disable SSH X11Forwarding
# Set SSH MaxAuthTries to 3
# Set SSH MaxAuthTriesLog to 0
# Set SSH IgnoreRhosts to yes
# Set SSH RhostsAuthentication to no
# Set SSH RhostsRSAAuthentication to no
# Disable SSH root login
# Set SSH PermitEmptyPasswords to no
# Set SSH Banner
# Enable a Warning Banner for the SSH Service

audit_ssh_config () {
  check_file="/etc/ssh/sshd_config"
  #audit_file_value $check_file Host space "*" hash
  audit_file_value $check_file Protocol space 2 hash
  audit_file_value $check_file X11Forwarding space no hash
  if [ "$os_name" = "Linux" ]; then
    if [ "$os_version" = "6" ]; then
      audit_file_value $check_file MaxAuthTries space 3 hash
      audit_file_value $check_file MaxAuthTriesLog space 0 hash
      audit_file_value $check_file RhostsAuthentication space no hash
    fi
  else
    audit_file_value $check_file MaxAuthTries space 3 hash
    audit_file_value $check_file MaxAuthTriesLog space 0 hash
    audit_file_value $check_file RhostsAuthentication space no hash
  fi
  audit_file_value $check_file IgnoreRhosts space yes hash
  audit_file_value $check_file RhostsRSAAuthentication space no hash
  audit_file_value $check_file PermitRootLogin space no hash
  audit_file_value $check_file PermitEmptyPasswords space no hash
  audit_file_value $check_file PermitUserEnvironment space no hash
  audit_file_value $check_file HostbasedAuthentication space no hash
  audit_file_value $check_file Banner space /etc/issue hash
  audit_file_value $check_file ClientAliveInterval space 300 hash
  audit_file_value $check_file ClientAliveCountMax space 0 hash
  audit_file_value $check_file LogLevel space VERBOSE hash
  # Enable on new machines
  # audit_file_value $check_file Cipher space "aes128-ctr,aes192-ctr,aes256-ctr" hash
}

# Disable login: Prompts on Serial Ports

audit_serial_login () {
  if [ "$os_name" = "SunOS" ]; then
    total=`expr $total + 1`
    if [ "$os_version" = "10" ]; then
      serial_test=`pmadm -L |egrep "ttya|ttyb" |cut -f4 -d ":" |grep "ux" |wc -l`
      log_file="$work_dir/pmadm.log"
      if [ `expr "$serial_test" : "2"` = 1 ]; then
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score + 1`
          echo "Secure:    Serial port logins disabled [$score]"
        fi
      else
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score - 1`
          echo "Warning:   Serial port logins not disabled [$score]"
        fi
        if [ "$audit_mode" = 0 ]; then
          echo "Setting:   Serial port logins to disabled"
          echo "ttya,ttyb" >> $log_file
          pmadm -d -p zsmon -s ttya
          pmadm -d -p zsmon -s ttyb
        fi
      fi
      if [ "$audit_mode" = 2 ]; then
        restore_file="$restore_dir/pmadm.log"
        if [ -f "$restore_file" ]; then
          echo "Setting:   Serial port logins to enabled"
          pmadm -e -p zsmon -s ttya
          pmadm -e -p zsmon -s ttyb
        fi
      fi
    fi
  fi
}

# Disable "nobody" Access for RPC Encryption Key Storage Service

audit_nobody_rpc () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      check_file="/etc/default/keyserv"
      audit_file_value $check_file ENABLE_NOBODY_KEYS eq NO hash
    fi
  fi
}

# Disable .rhosts Support in /etc/pam.conf

audit_pam_rhosts () {
  if [ "$os_name" = "SunOS" ]; then
    check_file="/etc/pam.conf"
    total=`expr $total + 1`
    if [ "$audit_mode" = 2 ]; then
      funct_restore_file $check_file $restore_dir
    else
      echo "Checking:  Rhost authentication disabled in $check_file"
      pam_check=`cat $check_file | grep -v "^#" |grep "pam_rhosts_auth" |head -1 |wc -l`
      if [ "$pam_check" = "1" ]; then
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score -1`
          echo "Warning:   Rhost authentication enabled in $check_file [$score]"
        else
          log_file="$work_dir$check_file"
          if [ ! -f "$log_file" ]; then
            echo "Saving:    File $check_file to $work_dir$check_file"
            find $check_file | cpio -pdm $work_dir 2> /dev/null
          fi
          echo "Setting:   Rhost authentication to disabled in $check_file"
          sed -e 's/^.*pam_rhosts_auth/#&/' < $check_file > $temp_file
          cat $temp_file > $check_file
          rm $temp_file
          if [ "$os_version" != "11" ]; then
            pkgchk -f -n -p $check_file 2> /dev/null
          else
            pkg fix `pkg search $check_file |grep pkg |awk '{print $4}'`
          fi
        fi
      else
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score + 1`
          echo "Secure:    Rhost authentication disabled in $check_file [$score]"
        fi
      fi
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    for check_file in `ls /etc/pam.d/*`; do
      echo "Checking:  Rhost authentication disabled in $check_file [$score]"
      if [ "$audit_mode" = 2 ]; then
        funct_restore_file $check_file $restore_dir
      else
        pam_check=`cat $check_file | grep -v "^#" |grep "rhosts_auth" |head -1 |wc -l`
        if [ "$pam_check" = "1" ]; then
          if [ "$audit_mode" = 1 ]; then
            total=`expr $total + 1`
            score=`expr $score - 1`
            echo "Warning:   Rhost authentication enabled in $check_file [$score]"
          fi
          if [ "$audit_mode" = 0 ]; then
            funct_backup_file $check_file
            echo "Setting:   Rhost authentication to disabled in $check_file"
            sed -e 's/^.*rhosts_auth/#&/' < $check_file > $temp_file
            cat $temp_file > $check_file
            rm $temp_file
          fi
        else
          if [ "$audit_mode" = 1 ]; then
            total=`expr $total + 1`
            score=`expr $score + 1`
            echo "Secure:    Rhost authentication disabled in $check_file [$score]"
          fi
        fi
      fi
    done
  fi
}

# Restrict FTP Use

audit_ftp_users () {
  if [ "$os_name" = "SunOS" ]; then
    check_file=$1
    total=`expr $total + 1`
    for user_name in adm bin daemon gdm listen lp noaccess \
      nobody nobody4 nuucp postgres root smmsp svctag \
      sys uucp webserverd; do
      user_check=`cat /etc/passwd |cut -f1 -d":" |grep "^$user_name$"`
      if [ `expr "$user_check" : "[A-z]"` = 1 ]; then
        ftpuser_check=`cat $check_file |grep -v '^#' |grep "^$user_name$"`
        if [ `expr "$ftpuser_check" : "[A-z]"` != 1 ]; then
          if [ "$audit_mode" = 1 ]; then
            score=`expr $score - 1`
            echo "Warning:   User $user_name not in $check_file [$score]"
          fi
          if [ "$audit_mode" = 0 ]; then
            funct_backup_file $check_file
            echo "Setting:   User $user_name to not be allowed ftp access"
            funct_append_file $check_file $user_name hash
          fi
        else
          if [ "$audit_mode" = 1 ]; then
            score=`expr $score + 1`
            echo "Secure:    User $user_name in $check_file [$score]"
          fi
        fi
      fi
    done
    if [ "$audit_mode" = 2 ]; then
      funct_restore_file $check_file $restore_dir
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    check_file=$1
    total=`expr $total + 1`
    for user_name in root bin daemon adm lp sync shutdown halt mail \
    news uucp operator games nobody; do
      user_check=`cat /etc/passwd |cut -f1 -d":" |grep "^$user_name$"`
      if [ `expr "$user_check" : "[A-z]"` = 1 ]; then
        ftpuser_check=`cat $check_file |grep -v '^#' |grep "^$user_name$"`
        if [ `expr "$ftpuser_check" : "[A-z]"` != 1 ]; then
          if [ "$audit_mode" = 1 ]; then
            score=`expr $score - 1`
            echo "Warning:   User $user_name not in $check_file [$score]"
          fi
          if [ "$audit_mode" = 0 ]; then
            funct_backup_file $check_file
            echo "Setting:   User $user_name to not be allowed ftp access"
            funct_append_file $check_file $user_name hash
          fi
        else
          if [ "$audit_mode" = 1 ]; then
            score=`expr $score + 1`
            echo "Secure:    User $user_name in $check_file [$score]"
          fi
        fi
      fi
    done
    if [ "$audit_mode" = 2 ]; then
      funct_restore_file $check_file $restore_dir
    fi
  fi
}

audit_ftp_conf () {
  if [ "$os_name" = "SunOS" ]; then
    audit_ftp_users /etc/ftpd/ftpusers
  fi
  if [ "$os_name" = "Linux" ]; then
    audit_ftp_users /etc/vsftpd/ftpusers
  fi
}

# Set Delay between Failed Login Attempts to 4

audit_login_delay () {
  if [ "$os_name" = "SunOS" ]; then
    check_file="/etc/default/login"
    audit_file_value $check_file SLEEPTIME eq 4 hash
  fi
}

# Set Default Screen Lock for CDE Users

audit_cde_screen_lock () {
  if [ "$os_name" = "SunOS" ]; then
    for check_file in `ls /usr/dt/config/*/sys.resources 2> /dev/null`; do
      dir_name=`dirname $check_file |sed 's/usr/etc/'`
      if [ ! -d "$dir_name" ]; then
        mkdir -p $dir_name
      fi
      new_file="$dir_name/sys.resources"
      audit_file_value $new_file "dtsession*saverTimeout" colon " 10" star
      audit_file_value $new_file "dtsession*lockTimeout" colon " 10" star
      if [ "$audit_mode" = 0 ]; then
        if [ -f "$new_file" ]; then
          audit_check_perms $new_file 0444 root sys
        fi
      fi
    done
  fi
}

# Set Default Screen Lock for GNOME Users

audit_gnome_screen_lock () {
  if [ "$os_name" = "SunOS" ]; then
    check_file="/usr/openwin/lib/app-defaults/XScreenSaver"
    audit_file_value $check_file "*timeout:" space "0:10:00" bang
    audit_file_value $check_file "*lockTimeout:" space "0:00:00" bang
    audit_file_value $check_file "*lockTimeout:" space "0:00:00" bang
  fi
}

# Restrict at/cron to Authorized Users

audit_cron_allow () {
  check_file="/etc/cron.deny"
  funct_file_exists $check_file yes
}

# Restrict root Login to System Console

audit_console_login () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      check_file="/etc/default/login"
      audit_file_value $check_file CONSOLE eq /dev/console hash
    fi
    if [ "$os_version" = "11" ]; then
      service_name="svc:/system/console-login:terma"
      audit_service $service_name disabled
      service_name="svc:/system/console-login:termb"
      audit_service $service_name disabled
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    disable_ttys=0
    check_file="/etc/securetty"
    console_list=""
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  Remote consoles"
      for console_device in `cat $check_file |grep '^tty[0-9]'`; do
        disable_ttys=1
        console_list="$console_list $console_device"
      done
      if [ "$disable_ttys" = 1 ]; then
        if [ "$audit_mode" = 1 ]; then
          total=`expr $total + 1`
          score=`expr $score - 1`
          echo "Warning:   Consoles enabled on$console_list [$score]"
        fi
        if [ "$audit_mode" = 0 ]; then
          funct_backup_file $check_file
          echo "Setting:   Consoles to disabled on$console_list"
          cat $check_file |sed 's/tty[0-9].*//g' |grep '[a-z]' > $temp_file
          cat $temp_file > $check_file
          rm $temp_file 
        fi
      else
        if [ "$audit_mode" = 1 ]; then
          total=`expr $total + 1`
          score=`expr $score + 1`
          echo "Secure:    No consoles enabled on tty[0-9]* [$score]"
        fi
      fi
    else
      funct_restore_file $check_file $restore_dir
    fi
  fi
}

# Set Retry Limit for Account Lockout

audit_retry_limit () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      check_file="/etc/default/login"
      audit_file_value $check_file RETRIES eq 3 hash
      check_file="/etc/security/policy.conf"
      audit_file_value $check_file LOCK_AFTER_RETRIES eq YES hash
      if [ "$os_version" = "11" ]; then
        svcadm restart svc:/system/name-service/cache
      fi
    fi
  fi
}

# Set EEPROM Security Mode and Log Failed Access
# Haven't coded anything for this as don't see any value for it in a DC

audit_eeprom_security () {
  :
}

# Secure the GRUB Menu

audit_grub_security () {
#  if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
#    check_file="/boot/grub/menu.lst"
#    grub_check=`cat $check_file |grep "^password --md5" |awk '{print $1}'`
#    if [ "$grub_check" != "password" ]; then
#      if [ "$audit_mode" = 1 ]; then
#        score=`expr $score - 1`
#        echo "Warning:   Grub password not set [$score]"
#      fi
#      This code needs work
#      if [ "$audit_mode" = 0 ]; then
#        echo "Setting:   Grub password"
#        if [ ! -f "$log_file" ]; then
#          echo "Saving:    File $check_file to $log_file"
#          find $check_file | cpio -pdm $work_dir 2> /dev/null
#        fi
#   echo -n "Enter password: "
#   read $password_string
#   password_string=`htpasswd -nb test $password_string |cut -f2 -d":"`
#   echo "password --md5 $password_string" >> $check_file
#   chmod 600 $check_file
#   lock_check=`cat $check_file |grep lock`
#   if [ "$lock_check" != "lock"]; then
#     cat $check_file |sed 's,Solaris failsafe,Solaris failsafe\
#Lock,g' >> $temp_file
#     cp $temp_file $check_file
#     rm $temp_file
#   fi
#     fi
#    else
#      if [ "$audit_mode" = 1 ]; then
#        score=`expr $score + 1`
#        echo "Secure:    Set-UID not restricted on user mounted devices [$score]"
#      fi
#      if [ "$audit_mode" = 2 ]; then
#        restore_file="$restore_dir$check_file"
#        if [ -f "$restore_file" ]; then
#          echo "Restoring:  $restore_file to $check_file"
#          cp -p $restore_file $check_file
#          if [ "$os_version" = "10" ]; then
#            pkgchk -f -n -p $check_file 2> /dev/null
#          else
#            pkg fix `pkg search $check_file |grep pkg |awk '{print $4}'`
#          fi
#        fi
#      fi
#    fi
#  fi
  :
}

# Disable System Accounts

audit_system_accounts () {
#  for user_name in bin nuucp smmsp listen gdm webserverd nobody noaccess nobody4 svctag; do
    :
#  done
}

# Set Password Expiration Parameters on Active Accounts
#
# For Linux this will apply to new accounts
# To fix existing accounts:
# useradd -D -f 7
# chage -m 7 -M 90 -W 14 -I 7

audit_password_expiry () {
  if [ "$os_name" = "SunOS" ]; then
    check_file="/etc/default/passwd"
    audit_file_value $check_file PASSLENGTH eq 8 hash
    audit_file_value $check_file MAXWEEKS eq 13 hash
    audit_file_value $check_file MINWEEKS eq 1 hash
    audit_file_value $check_file WARNWEEKS eq 4 hash
  fi
  if [ "$os_name" = "Linux" ]; then
    check_file="/etc/login.defs"
    audit_file_value $check_file PASS_MAX_DAYS eq 90 hash
    audit_file_value $check_file PASS_MIN_DAYS eq 7 hash
    audit_file_value $check_file PASS_WARN_AGE eq 14 hash
    audit_file_value $check_file PASS_MIN_LEN eq 9 hash
    audit_check_perms $check_file 0640 root root
  fi
}

# Set Strong Password Creation Policies

audit_strong_password () {
  if [ "$os_name" = "SunOS" ]; then
    check_file="/etc/default/passwd"
    audit_file_value $check_file PASSLENGTH eq 8 hash
    audit_file_value $check_file NAMECHECK eq YES hash
    audit_file_value $check_file HISTORY eq 10 hash
    audit_file_value $check_file MINDIFF eq 3 hash
    audit_file_value $check_file MINALPHA eq 2 hash
    audit_file_value $check_file MINUPPER eq 1 hash
    audit_file_value $check_file MINLOWER eq 1 hash
    audit_file_value $check_file MINNONALPHA eq 1 hash
    audit_file_value $check_file MAXREPEATS eq 0 hash
    audit_file_value $check_file WHITESPACE eq YES hash
    audit_file_value $check_file DICTIONDBDIR eq /var/passwd hash
    audit_file_value $check_file DICTIONLIST eq /usr/share/lib/dict/words hash
  fi
}

# Set Default Group for root Account

audit_root_group () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  Root default group"
    fi
    group_check=`grep root /etc/passwd | cut -f4 -d":"`
    log_file="$work_dir/rootgroup.log"
    total=`expr $total + 1`
    if [ "$group_check" != 0 ]; then
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score - 1`
        echo "Warning:   Root default group incorrectly set [$score]"
      fi
      if [ "$audit_mode" = 0 ]; then
        echo "$group_check" >> $log_file
        echo "Setting:   Root default group correctly"
        passmgmt -m -g 0 root
      fi
    else
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score + 1`
        echo "Secure:    Root default group correctly set [$score]"
      fi
    fi
    if [ "$audit_mode" = 2 ]; then
      restore_file="$restore_dir/rootgroup.log"
      if [ -f "$restore_file" ]; then
        $group_check=`cat $restore_file`
        echo "Restoring: Root default group $group_check"
        passmgmt -m -g $group_check root
      fi
    fi
  fi
}

# Change Home Directory for root Account

audit_root_home () {
  if [ "$os_name" = "SunOS" ]; then
    total=`expr $total + 1`
    if [ "$os_name" = "SunOS" ]; then
      if [ "$os_version" = "10" ]; then
        if [ "$audit_mode" != 2 ]; then
          echo "Checking:  Root home directory"
        fi
        home_check=`grep root /etc/passwd | cut -f6 -d:`
        log_file="$work_dir/roothome.log"
        if [ "$home_check" != "/root" ]; then
          if [ "$audit_mode" = 1 ]; then
            score=`expr $score - 1`
            echo "Warning:   Root home directory incorrectly set [$score]"
          fi
          if [ "$audit_mode" = 0 ]; then
            echo "$home_check" >> $log_file
            echo "Setting:   Root home directory correctly"
            mkdir -m 700 /root
            mv -i /.?* /root/
            passmgmt -m -h /root root
          fi
        else
          if [ "$audit_mode" = 1 ]; then
            score=`expr $score + 1`
            echo "Secure:    Root home directory correctly set [$score]"
          fi
        fi
        if [ "$audit_mode" = 2 ]; then
          restore_file="$restore_dir/rootgroup.log"
          if [ -f "$restore_file" ]; then
            $home_check=`cat $restore_file`
            echo "Restoring: Root home directory $home_check"
            mv -i $home_check/.?* /
            passmgmt -m -h $group_check root
          fi
        fi
      fi
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
      audit_check_perms /root 0700 root root
  fi
}

# Set Default umask for Users

audit_default_umask () {
  if [ "$os_name" = "SunOS" ]; then
    check_file="/etc/default/login"
    audit_file_value $check_file UMASK space 077 hash
  fi
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    for check_file in /etc/.login /etc/profile /etc/skel/.bash_profile \
      /etc/skel/.bashrc; do
      audit_file_value $check_file "umask" space 077 hash
    done
  fi
}

# Set Default umask for FTP Users

audit_ftp_umask () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      check_file="/etc/ftpd/ftpaccess"
      audit_file_value $check_file defumask space 077 hash
    fi
    if [ "$os_version" = "11" ]; then
      check_file="/etc/proftpd.conf"
      audit_file_value $check_file Umask space 027 hash
    fi
  fi
}

# Set "mesg n" as Default for All Users

audit_mesgn () {
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    for check_file in /etc/.login /etc/profile /etc/skel/.bash_profile \
      /etc/skel/.bashrc; do
      audit_file_value $check_file mesg space n hash
    done
  fi
}

# Lock Inactive User Accounts

audit_inactive_users () {
  if [ "$os_name" = "SunOS" ]; then
    check_file="/usr/sadm/defadduser"
    audit_file_value $check_file definact eq 35 hash
    check_file="/etc/shadow"
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:   Inactive lockout"
      total=`expr $total + 1`
      for user_check in `cat $check_file |grep -v 'nobody4'`; do
        inactive_check=`echo $user_check |cut -f 7 -d":"`
        user_name=`echo $user_check |cut -f 1 -d":"`
        if [ "$inactive_check" == "" ]; then
          if [ "$audit_mode" = 1 ]; then
            score=`expr $score - 1`
            echo "Warning:   Inactive lockout not set for $user_name [$score]"
          fi
          if [ "$audit_mode" = 0 ]; then
            echo "Saving:    File $check_file to $work_dir$check_file"
            find $check_file | cpio -pdm $work_dir 2> /dev/null
            echo "Setting:   Inactive lockout for $user_name [$score]"
            usermod -f 35 $user_name
          fi
        else
          if [ "$audit_mode" = 1 ]; then
            score=`expr $score + 1`
            echo "Secure:    Inactive lockout set for $user_name [$score]"
          fi
        fi
      done
    else
      funct_restore_file $check_file $restore_dir
    fi
  fi
}

# Create Warnings for Standard Login Services

audit_security_banner () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  Security banners"
    fi
    funct_file_exists /etc/motd yes
    audit_check_perms /etc/motd 0644 root root
    funct_file_exists /etc/issue yes
    audit_check_perms /etc/issue 0644 root root
  fi
}

# Create Warning Banner for CDE Users

audit_cde_banner () {
  if [ "$os_name" = "SunOS" ]; then
    for check_file in /usr/dt/config/*/Xresources ; do
      dir_name=`dirname $check_file |sed 's/usr/etc/'`
      new_file="$dir_name/Xresources"
      if [ -f "$new_file" ]; then
        audit_file_value $new_file "Dtlogin*greeting.labelString" colon "Authorized uses only" star
        audit_file_value $new_file "Dtlogin*greeting.persLabelString" colon "Authorized uses only" star
      fi
    done
  fi
}

# Create Warning Banner for GNOME Users

audit_gnome_banner () {
  if [ "$os_name" = "SunOS" ]; then
    total=`expr $total + 1`
    if [ "$os_version" = "10" ]; then
      check_file="/etc/X11/gdm.conf"
      audit_file_value $check_file Welcome eq "Authorised users only" hash
    fi
    if [ "$os_version" = "11" ]; then
      check_file="/etc/gdm/Init/Default"
      if [ "$audit_mode" != 2 ]; then
        if [ -f "$check_file" ]; then
          gdm_check=`cat $check_file |grep 'Security Message' |cut -f3 -d"="`
          if [ "$gdm_check" != "/etc/issue" ]; then
            if [ "$audit_mode" = 1 ]; then
              score=`expr $score - 1`
              echo "Warning:   Warning banner not found in $check_file [$score]"
            fi
            if [ "$audit_mode" = 0 ]; then
              funct_backup_file $check_file
              echo "Setting:   Warning banner in $check_file"
              echo "   --title=\"Security Message\" --filename=/etc/issue" >> $check_file
              if [ "$os_version" = "10" ]; then
                pkgchk -f -n -p $check_file 2> /dev/null
              else
                pkg fix `pkg search $check_file |grep pkg |awk '{print $4}'`
              fi
            fi
          fi
          if [ "$file_entry" = "" ]; then
            if [ "$audit_mode" = 1 ]; then
              score=`expr $score + 1`
              echo "Secure:    Warning banner in $check_file [$score]"
            fi
          fi
        else
          funct_restore_file $check_file $restore_dir
        fi
      fi
    fi
  fi
}

# Enable TCP SYN Cookie Protection

audit_tcpsyn_cookie () {
  if [ "$os_name" = "Linux" ]; then
    check_file="/etc/rc.d/local"
    funct_append_file $check_file "echo 1 > /proc/sys/net/ipv4/tcp_syncookies" hash
    audit_check_perms $check_file 0600 root root
  fi
}

# Create Warning Banner for FTP daemon

audit_ftp_banner () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ]; then
      check_file="/etc/ftpd/banner.msg"
      audit_file_value $check_file Authorised space "users only" hash
      if [ "$audit_mode" = 0 ]; then
        audit_check_perms $check_file 0444 root root
      fi
    fi
    if [ "$os_version" = "11" ]; then
      check_file="/etc/proftpd.conf"
      audit_file_value $check_file DisplayConnect space /etc/issue hash
      if [ "$audit_mode" = 0 ]; then
        svcadm restart ftp
      fi
    fi
  fi
}

# Check Banner Setting for telnet is Null

audit_telnet_banner () {
  if [ "$os_name" = "SunOS" ]; then
    check_file="/etc/default/telnetd"
    audit_file_value $check_file BANNER eq /etc/issue hash
  fi
}

# Check for Remote Consoles
# On Linux remove tty[0-9]* from /etc/securetty if run in lockdown mode

audit_remote_consoles () {
  if [ "$os_name" = "SunOS" ]; then
    disable_ttys=0
    log_file="remoteconsoles.log"
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  Remote consoles"
      log_file="$work_dir/$log_file"
      for console_device in `/usr/sbin/consadm -p`; do
        total=`expr $total + 1`
        disable_ttys=1
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score - 1`
          echo "Warning:   Console enabled on $console_device [$score]"
        fi
        if [ "$audit_mode" = 0 ]; then
          echo "$console_device" >> $log_file
          echo "Setting:   Console disabled on $console_device"
          consadm -d $console_device
        fi
      done
      if [ "$disable_ttys" = 1 ]; then
        if [ "$audit_mode" = 1 ]; then
          total=`expr $total + 1`
          score=`expr $score + 1`
          echo "Secure:    No remote consoles enabled [$score]"
        fi
      fi
    else
      restore_file="$restore_dir$log_file"
      if [ -f "$restore_file" ]; then
        for console_device in `cat $restore_file`; do
          echo "Restoring: Console to enabled on $console_device"
          consadm -a $console_device
        done
      fi
    fi
  fi
}

# Verify System File Permissions
# Use system package verification tool to generate list 
# of files that do not match the initial package permissions

audit_file_perms () {
  if [ "$os_name" = "SunOS" ]; then
    log_file="fileperms.log"
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  File permissions [This may take a while]"
      if [ "$os_version" = "11" ]; then
        error=0
        command=`pkg verify |grep file |awk '{print $2}'`
      else
        command=`pkgchk -n 2>&1 |grep ERROR |awk '{print $2}'`
      fi
      for check_file in $command; do
        if [ "$audit_mode" = 1 ]; then
          echo "Warning:   Incorrect permissions on $check_file"
        fi
        if [ "$audit_mode" = 0 ]; then
          if [ "$os_version" = "10" ]; then
            echo "Setting:   Correct permissions on $check_file"
            log_file="$work_dir/$log_file"
            file_perms=`ls -l $check_file |echo "obase=8;ibase=2;\`awk '{print $1}' |cut -c2-10 |tr 'xrws-' '11110'\`" |/usr/bin/bc`
            file_owner=`ls -l $check_file |awk '{print $3","$4}'`
            echo "$check_file,$file_perms,$file_owner" >> $log_file
            pkgchk -f -n -p $file_name 2> /dev/null
          else
            error=1
          fi
        fi
      done
      if [ "$os_version" = "11" ]; then
        if [ "$audit_mode" = 0 ]; then
          if [ "$error" = 1 ]; then
            log_file="$work_dir/$log_file"
            file_perms=`ls -l $check_file |echo "obase=8;ibase=2;\`awk '{print $1}' |cut -c2-10 |tr 'xrws-' '11110'\`" |/usr/bin/bc`
            file_owner=`ls -l $check_file |awk '{print $3","$4}'`
            echo "$check_file,$file_perms,$file_owner" >> $log_file
            pkg fix
          fi
        fi
      fi
    else
      restore_file="$restore_dir/$log_file"
      if [ -f "$restore_file" ]; then
        restore_check=`cat $restore_file |grep "$check_file" |cut -f1 -d","`
        if [ "$restore_check" = "$check_file" ]; then
          restore_info=`cat $restore_file |grep "$check_file"`
          restore_perms=`echo "$restore_info" |cut -f2 -d","`
          restore_owner=`echo "$restore_info" |cut -f3 -d","`
          restore_group=`echo "$restore_info" |cut -f4 -d","`
          echo "Restoring: File $check_file to previous permissions"
          chmod $restore_perms $check_file
          if [ "$check_owner" != "" ]; then
            chown $restore_owner:$restore_group $check_file
          fi
        fi
      fi
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    log_file="fileperms.log"
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  File permissions [This may take a while]"
      for rpm_name in `rpm -qa`; do
        for check_file=`rpm -V $rpm_name| awk '{print $2}'`; do
          if [ "$audit_mode" = 1 ]; then
            echo "Warning:   Incorrect permissions on $file_name"
          fi
          if [ "$audit_mode" = 0 ]; then
            echo "Setting:   Correct permissions on $file_name"
            log_file="$work_dir/$log_file"
            file_perms=`stat -c %a $check_file`
            file_owner=`ls -l $check_file |awk '{print $3","$4}'`
            echo "$check_file,$file_perms,$file_owner" >> $log_file
            yum reinstall $rpm_name
          fi
        done
      done
    else
      restore_file="$restore_dir/$log_file"
      if [ -f "$restore_file" ]; then
        restore_check=`cat $restore_file |grep "$check_file" |cut -f1 -d","`
        if [ "$restore_check" = "$check_file" ]; then
          restore_info=`cat $restore_file |grep "$check_file"`
          restore_perms=`echo "$restore_info" |cut -f2 -d","`
          restore_owner=`echo "$restore_info" |cut -f3 -d","`
          restore_group=`echo "$restore_info" |cut -f4 -d","`
          echo "Restoring: File $check_file to previous permissions"
          chmod $restore_perms $check_file
          if [ "$check_owner" != "" ]; then
            chown $restore_owner:$restore_group $check_file
          fi
        fi
      fi
    fi
  fi
}

# Ensure Password Fields are Not Empty
# Verify System Account Default Passwords
# Ensure Password Fields are Not Empty

audit_password_fields () {
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    check_file="/etc/shadow"
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  Password fields"
      total=`expr $total + 1`
      for user_name in `cat /etc/shadow |awk -F":" '{print $1":"$2":"}' |grep "::$" |cut -f1 -d":"`; do
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score - 1`
          echo "Warning:   No password field for $user_name in $check_file [$score]"
        fi
        if [ "$audit_mode" = 0 ]; then
          funct_backup_file $check_file
          echo "Setting:   No password for $user_name"
          passwd -d $user_name
          if [ "$os_name" = "SunOS" ]; then
            passwd -N $user_name
          fi
        fi
      done
    else
      funct_restore_file $check_file $restore_dir
    fi
  fi
}

# Verify No Legacy "+" Entries Exist in passwd, shadow, and group Files
# Prevent NIS maps from being inserted into files

audit_nis_entries () {
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  Legacy NIS '+' entries"
    fi
    total=`expr $total + 1`
    for check_file in /etc/passwd /etc/shadow /etc/group; do
      if [ "$audit_mode" != 2 ]; then
        for file_entry in `cat $check_file |grep "^+"`; do
          if [ "$audit_mode" = 1 ]; then
            score=`expr $score - 1`
            echo "Warning:   NIS entry \"$file_entry\" in $check_file [$score]"
          fi
          if [ "$audit_mode" = 0 ]; then
            funct_backup_file $check_file
            echo "Setting:   File $check_file to have no NIS entries"
            sed -e "s/^+/#&/" < $check_file > $temp_file
            cat $temp_file > $check_file
            if [ "$os_name" = "SunOS" ]; then
              if [ "$os_version" != "11" ]; then
                pkgchk -f -n -p $check_file 2> /dev/null
              else
                pkg fix `pkg search $check_file |grep pkg |awk '{print $4}'`
              fi
            fi
            rm $temp_file
          fi
        done
        if [ "$file_entry" = "" ]; then
          if [ "$audit_mode" = 1 ]; then
            score=`expr $score + 1`
            echo "Secure:    No NIS entries in $check_file [$score]"
          fi
        fi
      else
        funct_restore_file $check_file $restore_dir
      fi
    done
  fi
}

# Verify No UID 0 Accounts Exist Other than root
# Make sure no users other than root have UID 0

audit_super_users () {
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  Super users other than root"
      total=`expr $total + 1`
      for user_name in `awk -F: '$3 == "0" { print $1 }' /etc/passwd |grep -v root`; do
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score - 1`
          echo "Warning:   UID 0 for $user_name [$score]"
        fi
        if [ "$audit_mode" = 0 ]; then
          check_file="/etc/shadow"
          funct_backup_file $check_file
          check_file="/etc/passwd"
          backup_file="$work_dir$check_file"
          funct_backup_file $check_file
          echo "Removing:  Account $user_name it UID 0"
          userdel $user_name
        fi
      done
      if [ "$user_name" = "" ]; then
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score + 1`
          echo "Secure:    No accounts other than root have UID 0 [$score]"
        fi
      fi
    else
      check_file="/etc/shadow"
      funct_restore_file $check_file $restore_dir
      check_file="/etc/passwd"
      funct_restore_file $check_file $restore_dir
    fi
  fi
}

# Code to check permissions on a file
# If running in audit mode it will check permissions and report
# If running in lockdown mode it will fix permissions if they
# don't match those passed to routine
# Takes:
# check_file:   Name of file
# check_perms:  Octal of file permissions, eg 755
# check_owner:  Owner of file
# check_group:  Group ownership of file

audit_check_perms () {
  check_file=$1
  check_perms=$2
  check_owner=$3
  check_group=$4
  if [ "$audit_mode" != 2 ]; then
    echo "Checking:  File permissions on $check_file"
  fi
  total=`expr $total + 1`
  if [ ! -f "$check_file" ]; then
    if [ "$audit_mode" != 2 ]; then
      echo "Notice:    File $check_file does not exist"
    fi
    return
  fi
  if [ "$check_owner" != "" ]; then
    check_result=`find $check_file -perm $check_perms -user $check_owner -group $check_group`
  else
    check_result=`find $check_file -perm $check_perms`
  fi
  log_file="fileperms.log"
  if [ "$check_result" != "$check_file" ]; then
    if [ "$audit_mode" = 1 ]; then
      score=`expr $score - 1`
      echo "Warning:   File $check_file has incorrect permissions [$score]"
    fi
    if [ "$audit_mode" = 0 ]; then
      log_file="$work_dir/$log_file"
      if [ "$os_name" = "Solaris" ]; then
        file_perms=`truss -vstat -tstat ls -ld $check_file 2>&1 |grep 'm=' |tail -1 |awk '{print $3}' |cut -f2 -d'=' |cut -c4-7`
      fi
      if [ "$os_name" = "Linux" ]; then
        file_perms=`stat -c %a $check_file`
      fi
      file_owner=`ls -l $check_file |awk '{print $3","$4}'`
      echo "$check_file,$file_perms,$file_owner" >> $log_file
      echo "Setting:   File $check_file to have correct permissions [$score]"
      chmod $check_perms $check_file
      if [ "$check_owner" != "" ]; then
        chown $check_owner:$check_group $check_file
      fi
    fi
  else
    if [ "$audit_mode" = 1 ]; then
      score=`expr $score + 1`
      echo "Secure:    File $check_file has correct permissions [$score]"
    fi
  fi
  if [ "$audit_mode" = 2 ]; then
    restore_file="$restore_dir/$log_file"
    if [ -f "$restore_file" ]; then
      restore_check=`cat $restore_file |grep "$check_file" |cut -f1 -d","`
      if [ "$restore_check" = "$check_file" ]; then
        restore_info=`cat $restore_file |grep "$check_file"`
        restore_perms=`echo "$restore_info" |cut -f2 -d","`
        restore_owner=`echo "$restore_info" |cut -f3 -d","`
        restore_group=`echo "$restore_info" |cut -f4 -d","`
        echo "Restoring: File $check_file to previous permissions"
        chmod $restore_perms $check_file
        if [ "$check_owner" != "" ]; then
          chown $restore_owner:$restore_group $check_file
        fi
      fi
    fi
  fi
}

# Check for a dot file and remove it
# Remove is currently disabled

audit_dot_files () {
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    check_file=$1
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  For $check_file files"
      for dir_name in `cat /etc/passwd |cut -f6 -d':'`; do
        check_file="$dir_name/$check_file"
        if [ -f "$check_file" ]; then
          if [ "$audit_mode" = 1 ];then
            total=`expr $total + 1`
            score=`expr $score - 1`
            echo "Warning:   File $check_file exists [$score]"
          fi
          if [ "$audit_mode" = 0 ];then
            funct_backup_file $check_file
            #echo "Removing:  File $check_file"
            #funct_file_exists $check_file no
          fi
        fi
      done
    else
      for check_file in `cd $restore_dir ; find . -name "$check_file" |sed "s/^\.//g"`; do
        funct_restore_file $check_file $restore_dir
      done
    fi
  fi
}

# Ensure root PATH Integrity
# Make sure root PATH variable does not have errors which can be exploited

audit_root_path () {
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  Root PATH"
      total=`expr $total + 1`
      if [ "$audit_mode" = 1 ]; then
        if [ "`echo $PATH | grep :: `" != "" ]; then
          score=`expr $score - 1`
          echo "Warning:   Empty directory in PATH [$score]"
        else
          score=`expr $score + 1`
          echo "Secure:    No empty directory in PATH [$score]"
        fi
        if [ "`echo $PATH | grep :$`"  != "" ]; then
          score=`expr $score - 1`
          echo "Warning:   Trailing : in PATH [$score]"
        else
          score=`expr $score + 1`
          echo "Secure:    No trailing : in PATH [$score]"
        fi
        for dir_name in `echo $PATH | sed -e 's/::/:/' -e 's/:$//' -e 's/:/ /g'`; do
          if [ "$dir_name" = "." ]; then
            score=`expr $score - 1`
            echo "Warning:   PATH contains . [$score]"
          fi
          if [ -d "$dir_name" ]; then
            dir_perms=`ls -ld $dir_name | cut -f1 -d" "`
            if [ "`echo $dir_perms | cut -c6`" != "-" ]; then
              score=`expr $score - 1`
              echo "Warning:   Group write permissions set on directory $dir_name [$score]"
            else
              score=`expr $score + 1`
              echo "Secure:    Group write permission not set on directory $dir_name [$score]"
            fi
            if [ "`echo $dir_perms | cut -c9`" != "-" ]; then
              score=`expr $score - 1`
              echo "Warning:   Other write permissions set on directory $dir_name [$score]"
            else
              score=`expr $score + 1`
              echo "Secure:    Other write permission not set on directory $dir_name [$score]"
            fi
          fi
        done
      fi
    fi
  fi
}

# Check Permissions on User Home Directories
# Make sure passwords are only accessible by user

audit_home_perms () {
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  User home directory permissions"
    fi
    check_fail=0
    for home_dir in `cat /etc/passwd |cut -f6 -d":" |grep -v "^/$" |grep "home"`; do
      if [ -f "$check_file" ]; then
        audit_check_perms $check_file 0700
      fi
    done
  fi
}

# Check User Dot File Permissions
# Set permissions to be only read/write by user

audit_user_dotfiles () {
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  User dot file permissions"
    fi
    check_fail=0
    for home_dir in `cat /etc/passwd |cut -f6 -d":" |grep -v "^/$"`; do
      for check_file in $home_dir/.[A-Za-z0-9]*; do
        if [ -f "$check_file" ]; then
          audit_check_perms $check_file 0600
        fi
      done
    done
  fi
}

# Check Permissions on User .netrc Files
# Set permissions to be only read/write by user

audit_user_netrc () {
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  User netrc file permissions"
    fi
    check_fail=0
    for home_dir in `cat /etc/passwd |cut -f6 -d":" |grep -v "^/$"`; do
      check_file="$home_dir/.netrc"
      if [ -f "$check_file" ]; then
        check_fail=1
        audit_check_perms $check_file 0600
      fi
    done
    if [ "$check_fail" != 1 ]; then
      if [ "$audit_mode" = 1 ]; then
        total=`expr $total + 1`
        score=`expr $score + 1`
        echo "Secure:    No user netrc files exist [$score]"
      fi
    fi
  fi
}

# Check for Presence of User .rhosts Files

audit_user_rhosts () {
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  User rhosts files"
    fi
    check_fail=0
    for home_dir in `cat /etc/passwd |cut -f6 -d":" |grep -v "^/$"`; do
      check_file="$home_dir/.rhosts"
      if [ -f "$check_file" ]; then
        check_fail=1
        funct_file_exists $check_file no
      fi
    done
    if [ "$check_fail" != 1 ]; then
      if [ "$audit_mode" = 1 ]; then
        total=`expr $total + 1`
        score=`expr $score + 1`
        echo "Secure:    No user rhosts files exist [$score]"
      fi
    fi
  fi
}

# Check Groups in /etc/passwd

audit_groups_exist () {
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  Groups in passwd file exist in group file"
    fi
    check_file="/etc/group"
    group_fail=0
    total=`expr $total + 1`
    if [ "$audit_mode" != 2 ]; then
      for group_id in `getent passwd |cut -f4 -d ":"`; do
        group_exists=`cat $check_file |grep -v "^#" |cut -f3 -d":" |grep "^$group_id$" |wc -l |sed "s/ //g"`
        if [ "$group_exists" = 0 ]; then
          group_fail=1
          if [ "$audit_mode" = 1 ];then
            score=`expr $score - 1`
            echo "Warning:   Group $group_id does not exist in group file [$score]"
          fi
        fi
      done
      if [ "$group_fail" != 1 ]; then
        if [ "$audit_mode" = 1 ];then
          score=`expr $score + 1`
          echo "Secure:    No non existant group issues [$score]"
        fi
      fi
    fi
  fi
}

# Check That Users Are Assigned Home Directories
# Check That Defined Home Directories Exist
# Check User Home Directory Ownership

audit_home_ownership () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  Ownership of home directories"
    fi
    home_check=0
    total=`expr $total + 1`
    if [ "$audit_mode" != 2 ]; then
      getent passwd | awk -F: '{ print $1" "$6 }' | while read check_user home_dir; do
        found=0
        for test_user in root daemon bin sys adm lp uucp nuucp smmsp listen \
          gdm webservd postgres svctag nobody noaccess nobody4 unknown; do
          if [ "$check_user" = "$test_user" ]; then
            found=1
          fi
        done
        if [ "$found" = 0 ]; then
          home_check=1
          if [ -z "$home_dir" ] || [ "$home_dir" = "/" ]; then
            if [ "$audit_mode" = 1 ];then
              score=`expr $score - 1`
              echo "Warning:   User $check_user has no home directory defined [$score]"
            fi
          else
            if [ -d "$home_dir" ]; then
              dir_owner=`ls -ld $home_dir/. | awk '{ print $3 }'`
              if [ "$dir_owner" != "$check_user" ]; then
                if [ "$audit_mode" = 1 ];then
                  score=`expr $score - 1`
                  echo "Warning:   Home Directory for $check_user is owned by $dir_owner [$score]"
                fi
              else
                if [ -z "$home_dir" ] || [ "$home_dir" = "/" ]; then
                  if [ "$audit_mode" = 1 ];then
                    score=`expr $score - 1`
                    echo "Warning:   User $check_user has no home directory [$score]"
                  fi
                fi
              fi
            fi
          fi
        fi
      done
      if [ "$home_check" = 0 ]; then
        if [ "$audit_mode" = 1 ];then
          score=`expr $score + 1`
          echo "Secure:    No ownership issues with home directories [$score]"
        fi
      fi
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  Ownership of home directories"
    fi
    home_check=0
    total=`expr $total + 1`
    if [ "$audit_mode" != 2 ]; then
      getent passwd | awk -F: '{ print $1" "$6 }' | while read check_user home_dir; do
        found=0
        for test_user in root bin daemon adm lp sync shutdown halt mail news uucp \
          operator games gopher ftp nobody nscd vcsa rpc mailnull smmsp pcap ntp \
          dbus avahi sshd rpcuser nfsnobody haldaemon avahi-autoipd distcache apache \
          oprofile webalizer dovecot squid named xfs gdm sabayon; do
          if [ "$check_user" = "$test_user" ]; then
            found=1
          fi
        done
        if [ "$found" = 0 ]; then
          home_check=1
          if [ -z "$home_dir" ] || [ "$home_dir" = "/" ]; then
            if [ "$audit_mode" = 1 ];then
              score=`expr $score - 1`
              echo "Warning:   User $check_user has no home directory defined [$score]"
            fi
          else
            if [ -d "$home_dir" ]; then
              dir_owner=`ls -ld $home_dir/. | awk '{ print $3 }'`
              if [ "$dir_owner" != "$check_user" ]; then
                if [ "$audit_mode" = 1 ];then
                  score=`expr $score - 1`
                  echo "Warning:   Home Directory for $check_user is owned by $dir_owner [$score]"
                fi
              else
                if [ -z "$home_dir" ] || [ "$home_dir" = "/" ]; then
                  if [ "$audit_mode" = 1 ];then
                    score=`expr $score - 1`
                    echo "Warning:   User $check_user has no home directory [$score]"
                  fi
                fi
              fi
            fi
          fi
        fi
      done
      if [ "$home_check" = 0 ]; then
        if [ "$audit_mode" = 1 ];then
          score=`expr $score + 1`
          echo "Secure:    No ownership issues with home directories [$score]"
        fi
      fi
    fi
  fi
}

# Check That Reserved UIDs Are Assigned to System Accounts
# Make sure lower ids are only given to system accounts

audit_reserved_ids () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  Whether reserved UUIDs are assigned to system accounts"
    fi
    uuid_check=0
    total=`expr $total + 1`
    if [ "$audit_mode" != 2 ]; then
      getent passwd | awk -F: '($3 < 100) { print $1" "$3 }' | while read check_user check_uid; do
        found=0
        for test_user in root daemon bin sys adm lp uucp nuucp smmsp listen \
        gdm webservd postgres svctag nobody noaccess nobody4 unknown; do
          if [ "$check_user" = "$test_user" ]; then
            found=1
          fi
        done
        if [ "$found" = 0 ]; then
          uuid_check=1
          if [ "$audit_mode" = 1 ];then
            score=`expr $score - 1`
            echo "Warning:   User $check_user has a reserved UID ($check_uid) [$score]"
          fi
        fi
      done
      if [ "$uuid_check" = 0 ]; then
        if [ "$audit_mode" = 1 ];then
          score=`expr $score + 1`
          echo "Secure:    No non system users have a reserved UID [$score]"
        fi
      fi
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  Whether reserved UUIDs are assigned to system accounts"
    fi
    uuid_check=0
    total=`expr $total + 1`
    if [ "$audit_mode" != 2 ]; then
      getent passwd | awk -F: '($3 < 500) { print $1" "$3 }' | while read check_user check_uid; do
        found=0
        for test_user in root bin daemon adm lp sync shutdown halt mail news uucp \
          operator games gopher ftp nobody nscd vcsa rpc mailnull smmsp pcap ntp \
          dbus avahi sshd rpcuser nfsnobody haldaemon avahi-autoipd distcache apache \
          oprofile webalizer dovecot squid named xfs gdm sabayon; do
          if [ "$check_user" = "$test_user" ]; then
            found=1
          fi
        done
        if [ "$found" = 0 ]; then
          uuid_check=1
          if [ "$audit_mode" = 1 ];then
            score=`expr $score - 1`
            echo "Warning:   User $check_user has a reserved UID ($check_uid) [$score]"
          fi
        fi
      done
      if [ "$uuid_check" = 0 ]; then
        if [ "$audit_mode" = 1 ];then
          score=`expr $score + 1`
          echo "Secure:    No non system users have a reserved UID [$score]"
        fi
      fi
    fi
  fi
}

# Code to check for duplicate IDs
# Routine to check a file for duplicates
# Takes:
# field:      Field number
# function:   String describing action, eg users
# term:       String describing term, eg name
# check_file: File to parse

audit_duplicate_ids () {
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    field=$1
    function=$2
    term=$3
    duplicate=0
    check_file=$4
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  For $function with duplicate $term"
      total=`expr $total + 1`
      for file_info in `cat $check_file | cut -f$field -d":" | sort -n | uniq -c |awk '{ print $1":"$2 }'`; do
        file_check=`expr "$file_info" : "[A-z,0-9]"`
        if [ "$file_check" = 1 ]; then
          file_check=`expr "$file_info" : "2"`
          if [ "$file_check" = 1 ]; then
            file_id=`echo "$file_info" |cut -f2 -d":"`
            if [ "$audit_mode" = 1 ];then
              score=`expr $score - 1`
              echo "Warning:   There are multiple $function with $term $file_id [$score]"
              duplicate=1
            fi
          fi
        fi
      done
      if [ "$audit_mode" = 1 ]; then
        if [ "$duplicate" = 0 ];then
          score=`expr $score + 1`
          echo "Secure:    No $function with duplicate $term [$score]"
        fi
      fi
    fi
  fi
}

# Check for Duplicate UIDs
# Check for Duplicate User Names
# Duplicate UIDs or usernames may result in escalation of privileges through administative error

audit_duplicate_users () {
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    audit_duplicate_ids 1 users name /etc/passwd
    audit_duplicate_ids 3 users id /etc/passwd
  fi
}

# Check for Duplicate GIDs
# Check for Duplicate Group Names
# Duplicate groups may result in escalation of privileges through administative error

audit_duplicate_groups () {
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    audit_duplicate_ids 1 groups name /etc/group
    audit_duplicate_ids 3 groups id /etc/group
  fi
}

# Check for Presence of User .netrc Files
# .netrc files contain data for logging into a remote host for file transfers via FTP

audit_netrc_files () {
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    audit_dot_files .netrc
  fi
}

# Check for Presence of User .forward Files
# .forward files should be inspected to make sure information is not leaving the organisation

audit_forward_files () {
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    audit_dot_files .forward
  fi
}

# Find World Writable Files

audit_writable_files () {
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  For world writable files [This might take a while]"
    fi
    log_file="worldwritable.log"
    total=`expr $total + 1`
    if [ "$audit_mode" = 0 ]; then
      log_file="$work_dir/$log_file"
    fi
    if [ "$audit_mode" = 2 ]; then
      restore_file="$restore_dir/$log_file"
    fi
    if [ "$audit_mode" != 2 ]; then
      for check_file in `find / \( -fstype nfs -o -fstype cachefs \
        -o -fstype autofs -o -fstype ctfs -o -fstype mntfs \
        -o -fstype objfs -o -fstype proc \) -prune \
        -o -type f -perm -0002 -print`; do
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score - 1`
          echo "Warning:   File $check_file is world writable [$score]"
        fi
        if [ "$audit_mode" = 0 ]; then
          echo "$check_file" >> $log_file
          echo "Setting:   File $check_file non world writable [$score]"
          chmod o-w $check_file
        fi
      done
    fi
    if [ "$audit_mode" = 2 ]; then
      if [ -f "$restore_file" ]; then
        for check_file in `cat $restore_file`; do
          if [ -f "$check_file" ]; then
            echo "Restoring: File $check_file to previous permissions"
            chmod o+w $check_file
          fi
        done
      fi
    fi
  fi
}

# Find SUID/SGID System Executables

audit_suid_files () {
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    if [ "$audit_mode" = 1 ]; then
      echo "Checking:  For files with SUID/SGID set [This might take a while]"
      for check_file in `find / \( -fstype nfs -o -fstype cachefs \
        -o -fstype autofs -o -fstype ctfs -o -fstype mntfs \
        -o -fstype objfs -o -fstype proc \) -prune \
        -o -type f \( -perm -4000 -o -perm -2000 \) -print`; do
        echo "Warning:   File $check_file is SUID/SGID"
        file_type=`file $check_file |awk '{print $5}'`
        if [ "$file_type" != "script" ]; then
          elfsign_check=`elfsign verify -e $check_file 2>&1`
          echo "Result:    $elfsign_check"
        else
          echo "Result:    Shell script"
        fi
      done
    fi
  fi
}

# Find Un-owned Files and Directories

audit_unowned_files () {
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    if [ "$audit_mode" = 1 ]; then
      echo "Checking:  For Un-owned files and directories [This might take a while]"
      for check_file in `find / \( -fstype nfs -o -fstype cachefs \
        -o -fstype autofs -o -fstype ctfs -o -fstype mntfs \
        -o -fstype objfs -o -fstype proc \) -prune \
        -o \( -nouser -o -nogroup \) -print`; do
        total=`expr $total + 1`
        score=`expr $score - 1`
        echo "Warning:   File $check_file is unowned [$score]"
      done
    fi
  fi
}

# Find Files and Directories with Extended Attributes

audit_extended_attributes () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$audit_mode" = 1 ]; then
      echo "Checking:  For files and directories with extended attributes [This might take a while]"
      for check_file in `find / \( -fstype nfs -o -fstype cachefs \
        -o -fstype autofs -o -fstype ctfs -o -fstype mntfs \
        -o -fstype objfs -o -fstype proc \) -prune \
        -o -xattr -print`; do
        total=`expr $total + 1`
        score=`expr $score - 1`
        echo "Warning:   File $check_file has extended attributes [$score]"
      done
    fi
  fi
}

# Enable process accounting at boot time

audit_process_accounting () {
  if [ "$os_name" = "SunOS" ]; then
    check_file="/etc/rc3.d/S99acct"
    init_file="/etc/init.d/acct"
    log_file="$work_dir/acct.log"
    total=`expr $total + 1`
    if [ ! -f "$check_file" ]; then
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score - 1`
        echo "Warning:   Process accounting not enabled [$score]"
      fi
      if [ "$audit_mode" = 0 ]; then
        echo "Setting:   Process accounting to enabled"
        echo "disabled" > $log_file
        ln -s $init_file $check_file
        echo "Notice:    Starting Process accounting"
        $init_file start 2>&1 > /dev/null
      fi
    else
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score + 1`
        echo "Secure:    Process accounting not enabled [$score]"
      fi
      if [ "$audit_mode" = 2 ]; then
        log_file="$restore_dir/acct.log"
        if [ -f "$log_file" ]; then
          rm $check_file
          echo "Restoring: Process accounting to disabled"
          echo "Notice:    Stoping Process accounting"
          $init_file stop 2>&1 > /dev/null
        fi
      fi
    fi
  fi
}

# Use full path names in /etc/dfs/dfstab file

audit_dfstab () {
  if [ "$os_name" = "SunOS" ]; then
    funct_replace_value /etc/dfs/dfstab share /usr/bin/share start
  fi
}

# Restrict access to power management functions

audit_power_management () {
  if [ "$os_name" = "SunOS" ]; then
    total=`expr $total + 1`
    if [ "$os_version" = "10" ]; then
      audit_file_value /etc/default/power PMCHANGEPERM eq "-" hash
      audit_file_value /etc/default/power CPRCHANGEPERM eq "-" hash
    fi
    if [ "$os_version" = "11" ]; then
      poweradm_test=`poweradm list |grep suspend |awk '{print $2}' |cut -f2 -d"="`
      log_file="poweradm.log"
      if [ "$audit_mode" = 2 ]; then
        log_file="$restore_dir"
        if [ -f "$log_file" ]; then
          restore_value=`cat $log_file`
          if [ "$poweradm_test" != "$restore_value" ]; then
            poweradm set suspend-enable=$restore_value
            poweradm update
          fi
        fi
      fi
      if [ "$poweradm_test" != "false" ]; then
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score - 1`
          echo "Warning:   Power suspend enabled [$score]"
        fi
        if [ "$audit_mode" = 0 ]; then
          log_file="$work_dir/$log_file"
          echo "Setting:   Power suspend to disabled"
          echo "$poweradm_test" > $log_file
          poweradm set suspend-enable=false
          poweradm update
        fi
      else
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score + 1`
          echo "Secure:    Power suspend disabled [$score]"
        fi
      fi
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    service_name="apmd"
    audit_chkconfig_service $service_name 3 off
    audit_chkconfig_service $service_name 5 off
  fi
}

# Restrict access to sys-suspend feature

audit_sys_suspend () {
  if [ "$os_name" = "SunOS" ]; then
    audit_file_value /etc/default/sys-suspend PERMS eq "-" hash
  fi
}

# Create symlinks for dangerous files

audit_rhosts_files () {
  if [ "$os_name" = "SunOS" ]; then 
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      if [ "$audit_mode" != 2 ]; then
        echo "Checking:  Rhosts files"
      fi
      for check_file in /.rhosts /.shosts /etc/hosts.equiv; do
        funct_file_exists $check_file no
      done
    fi
  fi
  if [ "$os_name" = "Linux" ]; then 
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  Rhosts files"
    fi
    for check_file in /.rhosts /.shosts /etc/hosts.equiv; do
      funct_file_exists $check_file no
    done
  fi
}

# Remove Support for Internet Services (inetd)

audit_inetd () {
  if [ "$os_name" = "SunOS" ]; then 
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/inetd:default"
      audit_service $service_name disabled
    fi
  fi
}

# This one is optional, generally required for apps

audit_ssh_forwarding () {
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    check_file="/etc/ssh/sshd_config"
    audit_file_value $check_file AllowTcpForwarding space yes hash
  fi
}

# Create issue file

audit_issue_banner () {
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    total=`expr $total + 1`
    check_file="/etc/issue"
    issue_check=0
    if [ -f "$check_file" ]; then
      issue_check=`cat $check_file |grep 'NOTICE TO USERS' |wc -l`
    fi
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  Security message in $check_file"
      if [ "$issue_check" != 1 ]; then
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score - 1`
          echo "Warning:   No security message in $check_file [$score]"
        fi
        if [ "$audit_mode" = 0 ]; then
          echo "Setting:   Security message in $check_file"
          funct_backup_file $check_file
          echo "" > $check_file
          echo "                            NOTICE TO USERS" >> $check_file
          echo "                            ---------------" >> $check_file
          echo "This computer system is the private property of $company_name, whether" >> $check_file
          echo "individual, corporate or government. It is for authorized use only. Users" >> $check_file
          echo "(authorized & unauthorized) have no explicit/implicit expectation of privacy" >> $check_file
          echo "" >> $check_file
          echo "Any or all uses of this system and all files on this system may be" >> $check_file
          echo "intercepted, monitored, recorded, copied, audited, inspected, and disclosed" >> $check_file
          echo "to your employer, to authorized site, government, and/or law enforcement" >> $check_file
          echo "personnel, as well as authorized officials of government agencies, both" >> $check_file
          echo "domestic and foreign." >> $check_file
          echo "" >> $check_file
          echo "By using this system, the user expressly consents to such interception," >> $check_file
          echo "monitoring, recording, copying, auditing, inspection, and disclosure at the" >> $check_file
          echo "discretion of such officials. Unauthorized or improper use of this system" >> $check_file
          echo "may result in civil and criminal penalties and administrative or disciplinary" >> $check_file
          echo "action, as appropriate. By continuing to use this system you indicate your" >> $check_file
          echo "awareness of and consent to these terms and conditions of use. LOG OFF" >> $check_file
          echo "IMMEDIATELY if you do not agree to the conditions stated in this warning." >> $check_file
          echo "" >> $check_file
        fi
      else
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score + 1`
          echo "Secure:    Security message in $check_file [$score]"
        fi
      fi
    else
      funct_restore_file $check_file $restore_dir
    fi
  fi
}

# Samba: Set Group Ownership of smb.conf File
# Samba: Set Secure Permissions on smbpasswd File
# Samba: Set Group Ownership of smbpasswd File

audit_smbpasswd_perms () {
  if [ "$os_name" = "SunOS" ]; then
    audit_check_perms /etc/sfw/private/smbpasswd 0600 root root
  fi
}

# Samba: Set Secure Permissions on smb.conf File

audit_smbconf_perms () {
  if [ "$os_name" = "SunOS" ]; then
    audit_check_perms /etc/samba/smb.conf 0644 root root
  fi
}

# sendmail: Set Secure Permissions on Log File

audit_syslog_perms () {
  if [ "$os_name" = "SunOS" ]; then
    audit_check_perms /var/log/syslog 0640 root sys
  fi
}

# rarp: Turn off rarp if not in use
# rarp is required for jumpstart servers

audit_rarp () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/rarp:default"
      audit_service $service_name disabled
    fi
  fi
}

# Turn off wins if not required

audit_wins () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/wins:default"
      audit_service $service_name disabled
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    service_name="rarpd"
    audit_chkconfig_service $service_name 3 off
    audit_chkconfig_service $service_name 5 off
  fi
}

# Turn off winbind if not required

audit_winbind () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/winbind:default"
      audit_service $service_name disabled
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    service_name="winbind"
    audit_chkconfig_service $service_name 3 off
    audit_chkconfig_service $service_name 5 off
  fi
}

# Turn off bootparams if not required
# Required for jumpstart servers

audit_bootparams () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/rpc/bootparams:default"
      audit_service $service_name disabled
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    service_name="bootparamd"
    audit_chkconfig_service $service_name 3 off
    audit_chkconfig_service $service_name 5 off
  fi
}

# Turn off postgresql if not required
# Recommend removing this from base install as it slows down patching significantly

audit_postgresql () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/application/database/postgresql_83:default_32bit"
      audit_service $service_name disabled
      service_name="svc:/application/database/postgresql_83:default_64bit"
      audit_service $service_name disabled
      service_name="svc:/application/database/postgresql:version_81"
      audit_service $service_name disabled
      service_name="svc:/application/database/postgresql:version_82"
      audit_service $service_name disabled
      service_name="svc:/application/database/postgresql:version_82_64bit"
      audit_service $service_name disabled
    fi
  fi  
  if [ "$os_name" = "Linux" ]; then
    service_name="postgresql"
    audit_chkconfig_service $service_name 3 off
    audit_chkconfig_service $service_name 5 off
  fi
}

# Turn off webmin if not required

audit_webmin () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/application/management/webmin:default"
      audit_service $service_name disabled
    fi
  fi
}

# Turn off DNS Server if not required
# May be required for jumpstart servers

audit_dns_server () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/dns/server:default"
      audit_service $service_name disabled
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    for service_name in avahi-daemon avahi-dnsconfd named; do
      audit_chkconfig_service $service_name 3 off
      audit_chkconfig_service $service_name 5 off
    done
  fi
}

# Audit Avahi Daemon config

audit_avahi_conf () {
  if [ "$os_name" = "Linux" ]; then
    $check_file="/etc/avahi/avahi-daemon.conf"
    audit_file_value $check_file disable-user-service-publishing eq yes hash
    audit_file_value $check_file disable-publishing eq yes hash
    audit_file_value $check_file publish-address eq no hash
    audit_file_value $check_file publish-binfo eq no hash
    audit_file_value $check_file publish-workstation eq no hash
    audit_file_value $check_file publish-domain eq no hash
    audit_file_value $check_file disallow-other-stacks eq yes hash
    audit_file_value $check_file check-response-ttl eq yes hash
  fi
}

# Audit DNS Client

audit_dns_client () {
  if [ "$os_name" = "Linux" ]; then
    for service_name in nscd; do
      audit_chkconfig_service $service_name 3 off
      audit_chkconfig_service $service_name 5 off
    done
  fi
}

# Turn on NTP

audit_ntp () {
  if [ "$os_name" = "SunOS" ]; then
    check_file="/etc/inet/ntp.conf"
    audit_file_value $check_file server space pool.ntp.org hash
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/ntp4:default"
      audit_service $service_name enabled
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    echk_file="/etc/ntp.conf"
    total=`expr $total + 1`
    log_file="ntp.log"
    audit_linux_package check ntp
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  NTP is enabled"
    fi
    if [ "$package_name" != "ntp" ]; then
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score - 1`
        echo "Warning:   NTP not enabled [$score]"
      fi
      if [ "$audit_mode" = 0 ]; then
        echo "Setting:   NTP to enabled"
        log_file="$work_dir/$log_file"
        echo "Installed ntp" >> $log_file
        audit_linux_package install ntp
      fi
    else
      if [ "$audit_mode" = 1 ]; then
        score=`expr $score + 1`
        echo "Secure:    NTP enabled [$score]"
      fi
      if [ "$audit_mode" = 2 ]; then
        restore_file="$restore_dir/$log_file"
        audit_linux_package restore ntp $restore_file
      fi
    fi
    service_name="ntp"
    audit_chkconfig_service $service_name 3 off
    audit_chkconfig_service $service_name 5 off
    funct_append_file $check_file "restrict default kod nomodify nopeer notrap noquery" hash
    funct_append_file $check_file "restrict -6 default kod nomodify nopeer notrap noquery" hash
    audit_file_value $check_file OPTIONS eq "-u ntp:ntp -p /var/run/ntpd.pid" hash
  fi
}

# Turn off kerberos if not required

audit_krb5 () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/security/krb5kdc:default"
      audit_service $service_name disabled
      service_name="svc:/network/security/kadmin:default"
      audit_service $service_name disabled
      service_name="svc:/network/security/krb5_prop:default"
      audit_service $service_name disabled
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    for service_name in kadmin kprop krb524 krb5kdc; do
      audit_chkconfig_service $service_name 3 off
      audit_chkconfig_service $service_name 5 off
    done
  fi
}

# Turn off routing services if not required

audit_routing_daemons () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/routing/zebra:quagga"
      audit_service $service_name disabled
      service_name="svc:/network/routing/ospf:quagga"
      audit_service $service_name disabled
      service_name="svc:/network/routing/rip:quagga"
      audit_service $service_name disabled
      service_name="svc:/network/routing/ripng:default"
      audit_service $service_name disabled
      service_name="svc:/network/routing/ripng:quagga"
      audit_service $service_name disabled
      service_name="svc:/network/routing/ospf6:quagga"
      audit_service $service_name disabled
      service_name="svc:/network/routing/bgp:quagga"
      audit_service $service_name disabled
      service_name="svc:/network/routing/legacy-routing:ipv4"
      audit_service $service_name disabled
      service_name="svc:/network/routing/legacy-routing:ipv6"
      audit_service $service_name disabled
      service_name="svc:/network/routing/rdisc:default"
      audit_service $service_name disabled
      service_name="svc:/network/routing/route:default"
      audit_service $service_name disabled
      service_name="svc:/network/routing/ndp:default"
      audit_service $service_name disabled
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    for service_name in bgpd ospf6d ospfd ripd ripngd; do
      audit_chkconfig_service $service_name 3 off
      audit_chkconfig_service $service_name 5 off
    done
  fi
}

# Turn off ipmi environment daemon

audit_ipmi () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/ipmievd:default"
      audit_service $service_name disabled
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    for service_name in ipmi; do
      audit_chkconfig_service $service_name 3 off
      audit_chkconfig_service $service_name 5 off
    done
  fi
}

# Turn off apocd

audit_apocd () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/apocd/udp:default"
      audit_service $service_name disabled
    fi
  fi
}

# Turn off VNC

audit_vnc () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/application/x11/xvnc-inetd:default"
      audit_service $service_name disabled
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    for service_name in vncserver; do
      audit_chkconfig_service $service_name 3 off
      audit_chkconfig_service $service_name 5 off
    done
  fi
}

# Turn off IPSEC

audit_ipsec () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/ipsec/manual-key:default"
      audit_service $service_name disabled
      service_name="svc:/network/ipsec/ike:default"
      audit_service $service_name disabled
      service_name="svc:/network/ipsec/ipsecalgs:default"
      audit_service $service_name disabled
      service_name="svc:/network/ipsec/policy:default"
      audit_service $service_name disabled
    fi
  fi
}

# TUrn off ticotsord

audit_ticotsord () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/rpc-100235_1/rpc_ticotsord:default"
      audit_service $service_name disabled
    fi
  fi
}

# Turn off ftp server

audit_ftp_server () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/ftp:default"
      audit_service $service_name disabled
    fi
  fi
}

# Turn off IP filter

audit_ipfilter () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/ipfilter:default"
      audit_service $service_name disabled
      service_name="svc:/network/pfil:default"
      audit_service $service_name disabled
    fi
  fi
}

# Turn off echo and chargen services

audit_echo () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/echo:dgram"
      audit_service $service_name disabled
      service_name="svc:/network/echo:stream"
      audit_service $service_name disabled
      service_name="svc:/network/time:dgram"
      audit_service $service_name disabled
      service_name="svc:/network/time:stream"
      audit_service $service_name disabled
      service_name="svc:/network/tname:default"
      audit_service $service_name disabled
      service_name="svc:/network/comsat:default"
      audit_service $service_name disabled
      service_name="svc:/network/discard:dgram"
      audit_service $service_name disabled
      service_name="svc:/network/discard:stream"
      audit_service $service_name disabled
      service_name="svc:/network/chargen:dgram"
      audit_service $service_name disabled
      service_name="svc:/network/chargen:stream"
      audit_service $service_name disabled
      service_name="svc:/network/rpc/spray:default"
      audit_service $service_name disabled
      service_name="svc:/network/daytime:dgram"
      audit_service $service_name disabled
      service_name="svc:/network/daytime:stream"
      audit_service $service_name disabled
      service_name="svc:/network/talk:default"
      audit_service $service_name disabled
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    for service_name in telnet login rlogin rsh shell; do
      audit_chkconfig_service $service_name 3 off
      audit_chkconfig_service $service_name 5 off
    done
  fi
}

# Turn off remote shell services

audit_remote_shell () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/shell:kshell"
      audit_service $service_name disabled
      service_name="svc:/network/login:eklogin"
      audit_service $service_name disabled
      service_name="svc:/network/login:klogin"
      audit_service $service_name disabled
      service_name="svc:/network/rpc/rex:default"
      audit_service $service_name disabled
      service_name="svc:/network/rexec:default"
      audit_service $service_name disabled
      service_name="svc:/network/shell:default"
      audit_service $service_name disabled
      service_name="svc:/network/login:rlogin"
      audit_service $service_name disabled
      service_name="svc:/network/telnet:default"
      audit_service $service_name disabled
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    for service_name in telnet login rlogin rsh shell; do
      audit_chkconfig_service $service_name 3 off
      audit_chkconfig_service $service_name 5 off
    done
  fi
}

# Turn off cont server

audit_font_server () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/application/x11/xfs:default"
      audit_service $service_name disabled
      service_name="svc:/application/font/stfsloader:default"
      audit_service $service_name disabled
      service_name="svc:/application/font/fc-cache:default"
      audit_service $service_name disabled
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    for service_name in xfs; do
      audit_chkconfig_service $service_name 3 off
      audit_chkconfig_service $service_name 5 off
    done
  fi
}

# Turn off remote info services like rstat and finger

audit_remote_info () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/rpc/rstat:default"
      audit_service $service_name disabled
      service_name="svc:/network/nfs/rquota:default"
      audit_service $service_name disabled
      service_name="svc:/network/rpc/rusers:default"
      audit_service $service_name disabled
      service_name="svc:/network/finger:default"
      audit_service $service_name disabled
      service_name="svc:/network/rpc/wall:default"
      audit_service $service_name disabled
    fi
  fi
}

# Turn off NFS services

audit_nfs () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/nfs/mapid:default"
      audit_service $service_name disabled
      service_name="svc:/network/nfs/status:default"
      audit_service $service_name disabled
      service_name="svc:/network/nfs/cbd:default"
      audit_service $service_name disabled
      service_name="svc:/network/nfs/nlockmgr:default"
      audit_service $service_name disabled
      service_name="svc:/network/nfs/client:default"
      audit_service $service_name disabled
      service_name="svc:/network/nfs/server:default"
      audit_service $service_name disabled
    fi
    if [ "$os_version" != "11" ]; then
      service_name="nfs.server"
      audit_service $service_name disabled
    fi
    check_file="/etc/system"
    audit_file_value $check_file "nfssrv:nfs_portmon" eq 1 star
  fi
  if [ "$os_name" = "Linux" ]; then
    for service_name in nfs nfslock portmap rpc; do
      audit_chkconfig_service $service_name 3 off
      audit_chkconfig_service $service_name 5 off
    done
  fi
}

# Turn off tftp

audit_tftp_server () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/tftp/udp6:default"
      audit_service $service_name disabled
      service_name="svc:/network/tftp/udp4:default"
      audit_service $service_name disabled
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    audit_chkconfig_service tftp 3 off
    audit_chkconfig_service tftp 5 off
    if [ -e "/tftpboot" ]; then
      audit_check_perms /tftpboot 0744 root root
    fi
  fi  
}

# Turn off dhcp server

audit_dhcp_server () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/dhcp-server:default"
      audit_service $service_name disabled
    fi
  fi
}

# Turn off iscsi target

audit_iscsi () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/system/iscsitgt:default"
      audit_service $service_name disabled
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    service_name="iscsi"
    audit_chkconfig_service $service_name 3 off
    audit_chkconfig_service $service_name 5 off
    service_name="iscsd"
    audit_chkconfig_service $service_name 3 off
    audit_chkconfig_service $service_name 5 off
  fi
}

# Turn off boot services

audit_boot_server () {
  audit_rarp
  audit_bootparams
  audit_tftp_server
  audit_dhcp_server
}

# Turn off uucp

audit_uucp () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/swat:default"
      audit_service $service_name disabled
    fi
    if [ "$os_version" = "10" ]; then
      service_name="uucp"
      audit_service $service_name disabled
    fi
  fi
}

# Turn off ocfserv

audit_ocfserv () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/rpc/ocfserv:default"
      audit_service $service_name disabled
    fi
  fi
}

# Turn off hotplug

audit_hotplug () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/system/hotplug:default"
      audit_service $service_name disabled
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    service_name="pcscd"
    audit_chkconfig_service $service_name 3 off
    audit_chkconfig_service $service_name 5 off
    service_name="haldaemon"
    audit_chkconfig_service $service_name 3 off
    audit_chkconfig_service $service_name 5 off
    service_name="kudzu"
    audit_chkconfig_service $service_name 3 off
    audit_chkconfig_service $service_name 5 off
  fi
}

# Turn off tname

audit_tname () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/tname:default"
      audit_service $service_name disabled
    fi
  fi
}

# Turn off slp

audit_slp () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/slp:default"
      audit_service $service_name disabled
    fi
  fi
}

# Turn off tnd

audit_tnd () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/tnd:default"
      audit_service $service_name disabled
    fi
  fi
}

# Turn off labeld

audit_labeld () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/system/labeld:default"
      audit_service $service_name disabled
    fi
  fi
}

# Turn off ldap

audit_ldap () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/ldap/client:default"
      audit_service $service_name disabled
    fi
  fi
}

# Turn off kdm config

audit_kdm_config () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/platform/i86pc/kdmconfig:default"
      audit_service $service_name disabled
    fi
  fi
}

# Turn off bpcd

audit_bpcd () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/bpcd/tcp:default"
      audit_service $service_name disabled
    fi
  fi
}

# Turn off vnetd

audit_vnetd () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/vnetd/tcp:default"
      audit_service $service_name disabled
    fi
  fi
}

# Turn off vopied

audit_vopied () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/vopied/tcp:default"
      audit_service $service_name disabled
    fi
  fi
}

# Turn off bpjava-msvc

audit_bpjava_msvc () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/bpjava-msvc/tcp:default"
      audit_service $service_name disabled
    fi
  fi
}

# Turn off Service Tags

audit_service_tags () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/network/stdiscover:default"
      audit_service $service_name disabled
      service_name="svc:/network/stlisten:default"
      audit_service $service_name disabled
      service_name="svc:/application/stosreg:default"
      audit_service $service_name disabled
    fi
  fi
}

# Turn off Zone services

audit_zones () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      zone_check=`zoneadm list -civ |awk '{print $1}' |grep 1`
      if [ "$zone_check" != "1" ]; then
        service_name="svc:/system/rcap:default"
        audit_service $service_name disabled
        service_name="svc:/system/pools:default"
        audit_service $service_name disabled
        service_name="svc:/system/tsol-zones:default"
        audit_service $service_name disabled
        service_name="svc:/system/zones:default"
        audit_service $service_name disabled
      fi
    fi
  fi
}

# Turn off Xen services

audit_xen () {
  if [ "$os_name" = "Linux" ]; then
    service_name="xend"
    audit_chkconfig_service $service_name 3 off
    audit_chkconfig_service $service_name 5 off
    service_name="xendomains"
    audit_chkconfig_service $service_name 3 off
    audit_chkconfig_service $service_name 5 off
  fi
}

# Turn off SNMP

audit_snmp () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" = "10" ] || [ "$os_version" = "11" ]; then
      service_name="svc:/application/management/seaport:default"
      audit_service $service_name disabled
      service_name="svc:/application/management/snmpdx:default"
      audit_service $service_name disabled
      service_name="svc:/application/management/dmi:default"
      audit_service $service_name disabled
      service_name="svc:/application/management/sma:default"
      audit_service $service_name disabled
    fi
    if [ "$os_version" = "10" ]; then
      service_name="init.dmi"
      audit_service $service_name disabled
      service_name="init.sma"
      audit_service $service_name disabled
      service_name="init.snmpdx"
      audit_service $service_name disabled
    fi
  fi
  if [ "$os_name" = "Linux" ]; then
    service_name="snmpd"
    audit_chkconfig_service $service_name 3 off
    audit_chkconfig_service $service_name 5 off
    service_name="snmptrapd"
    audit_chkconfig_service $service_name 3 off
    audit_chkconfig_service $service_name 5 off
    funct_append_file /etc/snmp/snmpd.conf "com2sec notConfigUser default public" hash
  fi
}

# Audit modprobe.conf
# Check entries are in place so kernel modules can't be force loaded

audit_modprobe_conf () {
  if [ "$os_name" = "Linux" ]; then
    check_file="/etc/modprobe.conf"
    funct_append_file $check_file "install tipc /bin/true"
    funct_append_file $check_file "install rds /bin/true"
    funct_append_file $check_file "install sctp /bin/true"
    funct_append_file $check_file "install dccp /bin/true"
    #funct_append_file $check_file "install udf /bin/true"
    #funct_append_file $check_file "install squashfs /bin/true"
    #funct_append_file $check_file "install hfs /bin/true"
    #funct_append_file $check_file "install hfsplus /bin/true"
    #funct_append_file $check_file "install jffs2 /bin/true"
    #funct_append_file $check_file "install freevxfs /bin/true"
    #funct_append_file $check_file "install cramfs /bin/true"
  fi
}

# Network tuning parameters for sysctl under Linux
# Check and review to see which are suitable for you environment

audit_sysctl () {
  if [ "$os_name" = "Linux" ]; then
    check_file="/etc/sysctl.conf"
    audit_file_value $check_file net.ipv4.conf.default.secure_redirects eq 0 hash
    audit_file_value $check_file net.ipv4.conf.all.secure_redirects eq 0 hash
    audit_file_value $check_file net.ipv4.icmp_echo_ignore_broadcasts eq 1 hash
    audit_file_value $check_file net.ipv4.conf.all.accept_redirects eq 0 hash
    audit_file_value $check_file net.ipv4.conf.default.accept_redirects eq 0 hash
    audit_file_value $check_file net.ipv4.tcp_syncookies eq 1 hash
    audit_file_value $check_file net.ipv4.tcp_max_syn_backlog eq 4096 hash
    audit_file_value $check_file net.ipv4.conf.all.rp_filter eq 1 hash
    audit_file_value $check_file net.ipv4.conf.default.rp_filter eq 1 hash
    audit_file_value $check_file net.ipv4.conf.all.accept_source_route eq 0 hash
    audit_file_value $check_file net.ipv4.conf.default.accept_source_route eq 0 hash
    # Disable these if machine used as a firewall or gateway
    audit_file_value $check_file net.ipv4.tcp_max_orphans eq 256 hash
    audit_file_value $check_file net.ipv4.conf.all.log_martians eq 1 hash
    audit_file_value $check_file net.ipv4.ip_forward eq 0 hash
    audit_file_value $check_file net.ipv4.conf.all.send_redirects eq 0 hash
    audit_file_value $check_file net.ipv4.conf.default.send_redirects eq 0 hash
    audit_file_value $check_file net.ipv4.icmp_ignore_bogus_error_responses eq 1 hash
    # IPv6 stuff
    audit_file_value $check_file net.ipv6.conf.default.accept_redirects eq 0 hash
    audit_file_value $check_file net.ipv6.conf.default.accept_ra eq 0 hash
    # Randomise kernel memory placement
    audit_file_value $check_file kernel.randomize_va_space eq 1 hash
    # Configure kernel shield
    audit_file_value $check_file kernel.exec-shield eq 1 hash
    # Restrict core dumps
    audit_file_value $check_file fs.suid.dumpable eq 0 hash
    funct_append_file /etc/security/limits.conf "* hard core 0"
    # Check file permissions
    audit_check_perms $check_file 0600 root root  
  fi
}

# Audit xinetd services on Linux

audit_xinetd () {
  if [ "$os_name" = "Linux" ]; then
    xinetd_check=`cat /etc/xinetd.d/* |grep disable |awk '{print $3}' |grep no |head -1 |wc -l`
    if [ "$xinetd_check" = "1" ]; then
      for service_name in amanda amandaidx amidxtape auth chargen-dgram \
        chargen-stream cvs daytime-dgram daytime-stream discard-dgram \
        echo-dgram echo-stream eklogin ekrb5-telnet gssftp klogin krb5-telnet \
        kshell ktalk ntalk rexec rlogin rsh rsync talk tcpmux-server telnet \
        tftp time-dgram time-stream uucp; do
        audit_xinetd_service $service_name disable yes
      done
    else
      audit_chkconfig_service xinetd 3 off
      audit_chkconfig_service xinetd 5 off
    fi
  fi
}

# Turn off inetd and init.d services on Solaris (legacy for Solaris 10+)

audit_legacy () {
  if [ "$os_name" = "SunOS" ]; then
    if [ "$os_version" != "11" ]; then
      for service_name in time echo discard daytime chargen fs dtspc \
        exec comsat talk finger uucp name xaudio netstat ufsd rexd \
        systat sun-dr uuidgen krb5_prop 100068 100146 100147 100150 \
        100221 100232 100235 kerbd rstatd rusersd sprayd walld \
        printer shell login telnet ftp tftp 100083 100229 100230 \
        100242 100234 100134 100155 rquotad 100424 100422; do
        audit_inetd_service $service_name disabled
      done
      for service_name in llc2 pcmcia ppd slpd boot.server autoinstall \
        power bdconfig cachefs.daemon cacheos.finish asppp uucp flashprom \
        PRESERVE ncalogd ncad ab2mgr dmi mipagent nfs.client autofs rpc \
        directory ldap.client lp spc volmgt dtlogin ncakmod samba dhcp \
        nfs.server kdc.master kdc apache snmpdx; do
        audit_initd_service $service_name disabled
      done
    fi
  fi
}

# Turn off cups if not required on Linux

audit_cups () {
  if [ "$os_name" = "Linux" ]; then
    audit_chkconfig_service cups 3 off
    audit_chkconfig_service cups 5 off
    audit_check_perms /etc/init.d/cups 0744 root root
    audit_check_perms /etc/cups/cupsd.conf 0600 lp sys
    audit_check_perms /etc/cups/client.conf 0644 root lp
    audit_file_value /etc/cups/cupsd.conf User space lp hash
    audit_file_value /etc/cups/cupsd.conf Group space sys hash
  fi
}

# Code to check services are turned off via chkconfig in Linux

audit_chkconfig () {
  if [ "$os_name" = "Linux" ]; then
    for service_name in wu-ftpd ftp vsftpd \
      tftp acpid amd arptables_jg arpwatch atd netfs irda isdn \
      bluetooth capi conman cpuspeed cryrus-imapd dc_client \
      dc_server dhcdbd dhcp6s dhcrelay \
      dovecot dund gpm hidd hplip ibmasm innd ip6tables \
      lisa lm_sensors mailman mctrans mdmonitor mdmpd microcode_ctl \
      mysqld netplugd network NetworkManager openibd \
      pand postfix psacct mutipathd \
      radiusd radvd rdisc readahead_early readahead_later rhnsd \
      rpcgssd rpcimapd rpcsvcgssd rstatd rusersd rwhod saslauthd \
      settroubleshoot smartd spamassasin \
      tog-pegasus tux wpa_supplicant zebra; do
      audit_chkconfig_service $service_name 3 off
      audit_chkconfig_service $service_name 5 off
    done
  fi
}

# Code to check permission on log files under Linux

audit_linux_logfiles () {
  if [ "$os_name" = "Linux" ]; then
    for log_file in boot.log btml cron dmesg ksyms httpd lastlog maillog \
      mailman messages news pgsql rpm pkgs sa samba scrollkeeper.log \
      secure spooler squid vbox wtmp; do
      if [ -f "/var/log/$log_file" ]; then
        audit_check_perms /var/log/$log_file 0640 root root
      fi
    done
  fi
}

# Audit /etc/*passwd* permission under Linux

audit_passwd_perms () {
  if [ "$os_name" = "Linux" ]; then
    audit_check_perms /etc/group 0644 root root
    audit_check_perms /etc/passwd 0644 root root
    audit_check_perms /etc/gshadow 0400 root root
    audit_check_perms /etc/shadow 0400 root root
  fi
}

# Audit Sendmail Greeting

audit_sendmail_greeting () {
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    check_file="/etc/mail/sendmail.cf"
    search_string="v/"
    restore=0
    if [ "$audit_mode" != 2 ]; then
      total=`expr $total + 1`
      check_value=`cat $check_file |grep -v '^#' |grep 'O SmtpGreetingMessage' |awk '{print $4}' |grep 'v/'`
      if [ "$check_value" = "$search_string" ]; then
        if [ "$audit_mode" = "1" ]; then
          score=`expr $score - 1`
          echo "Warning:   Found version information in sendmail greeting [$score]"
        fi
        if [ "$audit_mode" = 0 ]; then
          funct_backup_file $check_file 
          echo "Setting:   Sendmail greeting to have no version information"
          cp $check_file $temp_file
          cat $temp_file |awk '/O SmtpGreetingMessage=/ { print "O SmtpGreetingMessage=Mail Server Ready; $b"; next} { print }' > $check_file
          rm $temp_file
        fi
      else
        if [ "$audit_mode" = "1" ]; then  
          score=`expr $score + 1`
          echo "Secure:    No version information in sendmail greeting [$score]"
        fi
      fi
    else
      funct_restore_file $check_file $restore_dir
    fi
    funct_disable_value $check_file "O HelpFile" hash
    if [ "$audit_mode" != 2 ]; then
      total=`expr $total + 1`
      check_value=`cat $check_file |grep -v '^#' |grep '$search_string'`
      if [ "$check_value" = "$search_string" ]; then
        if [ "$audit_mode" = "1" ]; then
          score=`expr $score - 1`
          echo "Warning:   Found help information in sendmail greeting [$score]"
        fi
        if [ "$audit_mode" = 0 ]; then
          funct_backup_file $check_file
          echo "Setting:   Sendmail to have no help information"
          cp $check_file $temp_file
          cat $temp_file |sed 's/^O HelpFile=/#O HelpFile=/' > $check_file
          rm $temp_file
        fi
      else
        if [ "$audit_mode" = "1" ]; then  
          score=`expr $score + 1`
          echo "Secure:    No help information in sendmail greeting [$score]"
        fi
      fi
    else
      funct_restore_file $check_file $restore_dir
    fi
    audit_check_perms $check_file 0444 root root
  fi
}

# Audit sendmail aliases

audit_sendmail_aliases () {
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    check_file="/etc/aliases"
    funct_disable_value $check_file "decode" hash
    audit_check_perms $check_file 0644 root root
  fi
}

# Audit /etc/pam.d/system-auth
# Lockout accounts after 5 failures
# Set to remember up to 4 passwords
# Set password length to a minimum of 9 characters
# Set strong password creation via pam_cracklib.so and pam_passwdqc.so

audit_system_auth () {
  if [ "$os_name" = "Linux" ]; then
    check_file="/etc/pam.d/system-auth"
    search_string="nullok"
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:   For nullok entry in $check_file"
      total=`expr $total + 1`
      check_value=0
      check_value=`cat $check_file |grep -v '^#' |grep 'nullok' |head -1 |wc -l`
      if [ "$check_value" = 1 ]; then
        if [ "$audit_mode" = "1" ]; then
          score=`expr $score - 1`
          echo "Warning:   Found nullok entry in $check_file [$score]"
        fi
        if [ "$audit_mode" = 0 ]; then
          funct_backup_file $check_file
          echo "Setting:   Removing nullok entries from $check_file"
          cp $check_file $temp_file
          cat $temp_file |sed 's/ nullok//' > $check_file
          rm $temp_file
        fi
      else
        if [ "$audit_mode" = "1" ]; then  
          score=`expr $score + 1`
          echo "Secure:    No nullok entries in $check_file [$score]"
        fi
      fi
    else
      funct_restore_file $check_file $restore_dir
    fi
    search_string="remember=5"
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  Password entry not enabled in $check_file"
      total=`expr $total + 1`
      check_value=`cat $check_file |grep '^account' |grep '$search_string$' |awk '{print $4}'`
      if [ "$check_value" != "$search_string" ]; then
        if [ "$audit_mode" = "1" ]; then
          score=`expr $score - 1`
          echo "Warning:   Password entry not enabled in $check_file [$score]"
        fi
        if [ "$audit_mode" = 0 ]; then
          funct_backup_file $check_file
          echo "Setting:   Password entry in $check_file"
          cp $check_file $temp_file
          cat $temp_file |awk '( $1 == "password" && $3 == "pam_unix.so" ) { print $0 " remember=5"; next };' > $check_file
          rm $temp_file
        fi
      else
        if [ "$audit_mode" = "1" ]; then  
          score=`expr $score + 1`
          echo "Secure:    Password entry enabled in $check_file [$score]"
        fi
      fi
    else
      funct_restore_file $check_file $restore_dir
    fi
    search_string="no_magic_root"
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  Auth entry not enabled in $check_file"
      total=`expr $total + 1`
      check_value=`cat $check_file |grep '^auth' |grep '$search_string$' |awk '{print $5}'`
      if [ "$check_value" != "$search_string" ]; then
        if [ "$audit_mode" = "1" ]; then
          score=`expr $score - 1`
          echo "Warning:   Auth entry not enabled in $check_file [$score]"
        fi
        if [ "$audit_mode" = 0 ]; then
          funct_backup_file $check_file
          echo "Setting:   Auth entry in $check_file"
          cp $check_file $temp_file
          cat $temp_file |awk '( $1 == "auth" && $2 == "required" && $3 == "pam_deny.so" ) { print "auth\trequired\tpam_tally2.so onerr=fail no_magic_root"; print $0; next };' > $check_file
          rm $temp_file
        fi
      else
        if [ "$audit_mode" = "1" ]; then  
          score=`expr $score + 1`
          echo "Secure:    Auth entry enabled in $check_file [$score]"
        fi
      fi
    else
      funct_restore_file $check_file $restore_dir
    fi
    search_string="reset"
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  Account entry not enabled in $check_file"
      total=`expr $total + 1`
      check_value=`cat $check_file |grep '^account' |grep '$search_string$' |awk '{print $6}'`
      if [ "$check_value" != "$search_string" ]; then
        if [ "$audit_mode" = "1" ]; then
          score=`expr $score - 1`
          echo "Warning:   Account entry not enabled in $check_file [$score]"
        fi
        if [ "$audit_mode" = 0 ]; then
          funct_backup_file $check_file
          echo "Setting:   Account entry in $check_file"
          cp $check_file $temp_file
          cat $temp_file |awk '( $1 == "account" && $2 == "required" && $3 == "pam_permit.so" ) { print "auth\trequired\tpam_tally2.so onerr=fail no_magic_root reset"; print $0; next };' > $check_file
          rm $temp_file
        fi
      else
        if [ "$audit_mode" = "1" ]; then  
          score=`expr $score + 1`
          echo "Secure:    Account entry enabled in $check_file [$score]"
        fi
      fi
    else
      funct_restore_file $check_file $restore_dir
    fi
    search_string="minlen=9"
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  Password minimum length not enabled in $check_file"
      total=`expr $total + 1`
      check_value=`cat $check_file |grep '^password' |grep '$search_string$' |awk '{print $8}'`
      if [ "$check_value" != "$search_string" ]; then
        if [ "$audit_mode" = "1" ]; then
          score=`expr $score - 1`
          echo "Warning:   Password minimum length not enabled in $check_file [$score]"
        fi
        if [ "$audit_mode" = 0 ]; then
          funct_backup_file $check_file
          echo "Setting:   Password minimum length in $check_file"
          cp $check_file $temp_file
          cat $temp_file |awk '( $1 == "password" && $2 == "requisite" && $3 == "pam_cracklib.so" ) { print $0  " dcredit=-1 lcredit=-1 ocredit=-1 ucredit=-1 minlen=9"; next }; { print }' > $check_file
          rm $temp_file
        fi
      else
        if [ "$audit_mode" = "1" ]; then  
          score=`expr $score + 1`
          echo "Secure:    Password minimum length enabled in $check_file [$score]"
        fi
      fi
    else
      funct_restore_file $check_file $restore_dir
    fi
  fi
  search_string="16,12,8"
  if [ "$audit_mode" != 2 ]; then
    echo "Checking:  Password minimum strength enabled in $check_file"
    total=`expr $total + 1`
    check_value=`cat $check_file |grep '^password' |grep '$search_string$' |awk '{print $8}'`
    if [ "$check_value" != "$search_string" ]; then
      if [ "$audit_mode" = "1" ]; then
        score=`expr $score - 1`
        echo "Warning:   Password minimum length not enabled in $check_file [$score]"
      fi
      if [ "$audit_mode" = 0 ]; then
        funct_backup_file $check_file
        echo "Setting:   Password minimum length in $check_file"
        cp $check_file $temp_file
        cat $temp_file |sed 's/^password.*pam_deny.so$/&\npassword\t\trequisite\t\t\tpam_passwdqc.so min=disabled,disabled,16,12,8/' > $check_file
        rm $temp_file
      fi
    else
      if [ "$audit_mode" = "1" ]; then  
        score=`expr $score + 1`
        echo "Secure:    Password minimum length enabled in $check_file [$score]"
      fi
    fi
  else
    funct_restore_file $check_file $restore_dir
  fi
  search_string="unlock_time=900"
  check_file="/etc/pam.d/password-auth"
  if [ "$audit_mode" != 2 ]; then
      echo "Checking:  Lockout for failed password attempts enabled in $check_file"
      total=`expr $total + 1`
      check_value=`cat $check_file |grep '^auth' |grep '$search_string$' |awk '{print $8}'`
      if [ "$check_value" != "$search_string" ]; then
        if [ "$audit_mode" = "1" ]; then
          score=`expr $score - 1`
          echo "Warning:   Lockout for failed password attempts not enabled in $check_file [$score]"
        fi
        if [ "$audit_mode" = 0 ]; then
          funct_backup_file $check_file
          echo "Setting:   Password minimum length in $check_file"
          cp $check_file $temp_file
          cat $temp_file |sed 's/^auth.*pam_env.so$/&\nauth\t\trequired\t\t\tpam_faillock.so preauth audit silent deny=5 unlock_time=900\nauth\t\t[success=1 default=bad]\t\t\tpam_unix.so\nauth\t\t[default=die]\t\t\tpam_faillock.so authfail audit deny=5 unlock_time=900\nauth\t\tsufficient\t\t\tpam_faillock.so authsucc audit deny=5 unlock_time=900\n/' > $check_file
          rm $temp_file
        fi
      else
        if [ "$audit_mode" = "1" ]; then  
          score=`expr $score + 1`
          echo "Secure:    Lockout for failed password attempts enabled in $check_file [$score]"
        fi
      fi
    else
      funct_restore_file $check_file $restore_dir
    fi
    search_string="unlock_time=900"
    check_file="/etc/pam.d/system-auth"
    if [ "$audit_mode" != 2 ]; then
        echo "Checking:  Lockout for failed password attempts enabled in $check_file"
        total=`expr $total + 1`
        check_value=`cat $check_file |grep '^auth' |grep '$search_string$' |awk '{print $8}'`
        if [ "$check_value" != "$search_string" ]; then
          if [ "$audit_mode" = "1" ]; then
            score=`expr $score - 1`
            echo "Warning:   Lockout for failed password attempts not enabled in $check_file [$score]"
          fi
          if [ "$audit_mode" = 0 ]; then
            funct_backup_file $check_file
            echo "Setting:   Password minimum length in $check_file"
            cp $check_file $temp_file
            cat $temp_file |sed 's/^auth.*pam_env.so$/&\nauth\t\trequired\t\t\tpam_faillock.so preauth audit silent deny=5 unlock_time=900\nauth\t\t[success=1 default=bad]\t\t\tpam_unix.so\nauth\t\t[default=die]\t\t\tpam_faillock.so authfail audit deny=5 unlock_time=900\nauth\t\tsufficient\t\t\tpam_faillock.so authsucc audit deny=5 unlock_time=900\n/' > $check_file
            rm $temp_file
          fi
        else
          if [ "$audit_mode" = "1" ]; then  
            score=`expr $score + 1`
            echo "Secure:    Lockout for failed password attempts enabled in $check_file [$score]"
          fi
        fi
      else
        funct_restore_file $check_file $restore_dir
      fi
}

# Add pam.deny to pam config files

audit_pam_deny () {
  :
}

# Make sure wheel group membership is required to su

audit_pam_wheel () {
  if [ "$os_name" = "Linux" ]; then
    check_file="/etc/pam.d/su"    
    search_string="use_uid"
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  Wheel group membership required for su in $check_file"
      total=`expr $total + 1`
      check_value=`cat $check_file |grep '^auth' |grep '$search_string$' |awk '{print $8}'`
      if [ "$check_value" != "$search_string" ]; then
        if [ "$audit_mode" = "1" ]; then
          score=`expr $score - 1`
          echo "Warning:   Wheel group membership not required for su in $check_file [$score]"
        fi
        if [ "$audit_mode" = 0 ]; then
          funct_backup_file $check_file
          echo "Setting:   Password minimum length in $check_file"
          cp $check_file $temp_file
          cat $temp_file |awk '( $1=="#auth" && $2=="required" && $3~"pam_wheel.so" ) { print "auth\t\trequired\t",$3,"\tuse_uid"; next }; { print }' > $check_file
          rm $temp_file
        fi
      else
        if [ "$audit_mode" = "1" ]; then  
          score=`expr $score + 1`
          echo "Secure:    Wheel group membership required for su in $check_file [$score]"
        fi
      fi
    else
      funct_restore_file $check_file $restore_dir
    fi
  fi
}

# Check that password hashing is set to SHA512

audit_password_hashing () {
  if [ "$os_name" = "Linux" ]; then
    if [ "$audit_mode" != 2 ]; then
      log_file="hashing.log"
      echo "Checking:  Password hashing is set to SHA512"
      total=`expr $total + 1`
      check_value=`authconfig --test |grep hashing |awk '{print $5}'`
      if [ "$check_value" != "sha512" ]; then
        if [ "$audit_mode" = "1" ]; then
          score=`expr $score - 1`
          echo "Warning:   Password hashing not set to SHA512 [$score]"
        fi
        if [ "$audit_mode" = 0 ]; then
          echo "Setting:   Password hashing to SHA512"
          log_file="$work_dir/$log_file"
          echo "$check_value" > $log_file
          authconfig --passalgo=sha512
        fi
      else
        if [ "$audit_mode" = "1" ]; then  
          score=`expr $score + 1`
          echo "Secure:    Password hashing set to SHA512 [$score]"
        fi
      fi
    else
      restore_file="$restore_dir/$log_file"
      if [ -f "$restore_file" ]; then
        check_value=`cat $restore_file`
        authconfig --passalgo=$check_value
      fi
    fi
  fi
}

audit_group_wheel () {
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    check_file="/etc/group"    
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  Wheel group exists in $check_file"
      total=`expr $total + 1`
      check_value=`cat $check_file |grep '^wheel:'`
      if [ "$check_value" != "$search_string" ]; then
        if [ "$audit_mode" = "1" ]; then
          score=`expr $score - 1`
          echo "Warning:   Wheel group does not exist in $check_file [$score]"
        fi
        if [ "$audit_mode" = 0 ]; then
          funct_backup_file $check_file
          echo "Setting:   Adding wheel group to $check_file"
          groupadd wheel
          usermod -G wheel root
        fi
      else
        if [ "$audit_mode" = "1" ]; then  
          score=`expr $score + 1`
          echo "Secure:    Wheel group exists in $check_file [$score]"
        fi
      fi
    else
      funct_restore_file $check_file $restore_dir
    fi
  fi
}

# Make sure not other accounts than root have UID 0

audit_super_users () {
  if [ "$os_name" = "SunOS" ] || [ "$os_name" = "Linux" ]; then
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  Super users other than root"
      total=`expr $total + 1`
      for user_name in `awk -F: '$3 == "0" { print $1 }' /etc/passwd |grep -v root`; do
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score - 1`
          echo "Warning:   UID 0 for $user_name [$score]"
        fi
        if [ "$audit_mode" = 0 ]; then
          check_file="/etc/shadow"
          funct_backup_file $check_file
          check_file="/etc/passwd"
          funct_backup_file $check_file
          echo "Removing:  Account $user_name as it has UID 0"
          userdel $user_name
        fi
      done
      if [ "$user_name" = "" ]; then
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score + 1`
          echo "Secure:    No accounts other than root have UID 0 [$score]"
        fi
      fi
    else
      check_file="/etc/shadow"
      funct_restore_file $check_file $restore_dir
      check_file="/etc/passwd"
      funct_restore_file $check_file $restore_dir
    fi
  fi
}

# Audit logrotate

audit_logrotate () {
  if [ "$os_name" = "Linux" ]; then
    check_file="/etc/logrotate.d/syslog"
    if [ "$audit_mode" != 2 ]; then
      echo "Checking:  Logrotate is set up"
      total=`expr $total + 1`
      search_string="/var/log/messages /var/log/secure /var/log/maillog /var/log/spooler /var/log/boot.log /var/log/cron"
      check_value=`cat $check_file |grep '$search_string'`
      if [ "$check_value" != "$search_string" ]; then
        score=`expr $score - 1`
        if [ "$audit_mode" = 1 ]; then
          echo "Warning:   UID 0 for $user_name [$score]"
        fi
        if [ "$audit_mode" = 0 ]; then
          funct_backup_file $check_file
          echo "Removing:  Configuring logrotate"
          cat $check_file |sed 's,.*{,$search_string {,' > $temp_file
          cat $temp_file > $check_file
          rm $temp_file
        fi
      else
        if [ "$audit_mode" = 1 ]; then
          score=`expr $score + 1`
          echo "Secure:    Log rotate is configured [$score]"
        fi
      fi
    else
      funct_restore_file $check_file $restore_dir
    fi
  fi
}

# Audit X11 Services

audit_x11_services () {
  audit_cde_ttdb
  audit_cde_cal
  audit_cde_spc
  audit_cde_print
  audit_xlogin
  audit_gdm_conf
  audit_cde_banner
  audit_gnome_banner
  audit_cde_screen_lock
  audit_gnome_screen_lock
  audit_opengl
  audit_font_server
  audit_vnc
}

# Audit Naming Services

audit_naming_services () {
  audit_nis_server
  audit_nis_client
  audit_nisplus
  audit_ldap_cache
  audit_kerberos_tgt
  audit_gss
  audit_keyserv
  audit_dns_client
  audit_dns_server
  audit_krb5
  audit_nis_entries
  audit_avahi_conf
}

# Audit users and groups

audit_user_services () {
  audit_root_home
  audit_mesgn
  audit_groups_exist
  audit_home_perms
  audit_home_ownership
  audit_duplicate_users
  audit_duplicate_groups
  audit_user_dotfiles
  audit_forward_files
  audit_root_path
  audit_root_group
  audit_default_umask
  audit_password_fields
  audit_reserved_ids
  audit_super_users
  audit_daemon_umask
  audit_cron_perms
  audit_group_wheel
  ##  audit_cron_allow
  ##  audit_system_accounts
}

# Audit print services

audit_print_services () {
  audit_ppd_cache
  audit_print
  audit_cups
}

# Audit web services

audit_web_services () {
  audit_webconsole
  audit_wbem
  audit_apache
  audit_webmin
}

# Audit disk and hardware related services

audit_disk_services () {
  audit_svm
  audit_svm_gui
  audit_hotplug
  audit_iscsi
  audit_power_management
  audit_sys_suspend
}

# Audit file permissions

audit_file_services () {
  audit_syslog_perms
  audit_volfs
  audit_autofs
  audit_dfstab
  audit_mount_setuid
  audit_mount_nodev
  audit_mount_fdi
  audit_nfs
  audit_uucp
}

# Audit sendmail

audit_sendmail_services () {
  audit_sendmail_daemon
  audit_sendmail_greeting
  audit_sendmail_aliases
}

# Audit FTP Services

audit_ftp_services () {
  audit_ftp_logging
  audit_ftp_umask
  audit_ftp_conf
  audit_ftp_server
  audit_tftp_server
  audit_ftp_banner
}

# Audit kernel services

audit_kernel_services () {
  audit_sysctl
  audit_kernel_accounting
  audit_kernel_params
  audit_tcpsyn_cookie
  audit_stack_protection
  audit_tcp_strong_iss
  audit_routing_params
  audit_modprobe_conf
  audit_unconfined_daemons
  audit_selinux
}

# Audit routing services

audit_routing_services () {
  audit_routing_daemons
  audit_routing_params
}

# Audit windows services 

audit_windows_services () {
  audit_smbpasswd_perms
  audit_smbconf_perms
  audit_samba
  audit_wins
  audit_winbind
}

# Audit startup services

audit_startup_services () {
  audit_xinetd
  audit_chkconfig
  audit_legacy
  audit_inetd
  audit_inetd_logging
}

# Audit remote shell services

audit_shell_services () {
  audit_issue_banner
  audit_ssh_config
  audit_remote_consoles
  audit_ssh_forwarding
  audit_remote_shell
  audit_console_login
  #audit_security_banner
  audit_telnet_banner
  audit_pam_rhosts
  #audit_user_netrc
  #audit_user_rhosts
  audit_rhosts_files
  audit_netrc_files
  audit_serial_login
  audit_sulogin
}

# Audit accounting services

audit_accounting_services () {
  audit_system_accounting
  audit_process_accounting
  audit_audit_class
}

# Audit firewall related services

audit_firewall_services () {
  audit_ipsec
  audit_ipfilter
  audit_tcp_wrappers
}

# Audit password related services

audit_password_services () {
  audit_system_auth
  audit_password_expiry
  audit_strong_password
  audit_passwd_perms
  audit_retry_limit
  audit_login_records
  audit_failed_logins
  audit_login_delay
  audit_pam_wheel
  audit_password_hashing
  audit_pam_deny
}

# Audit log files and log related services

audit_log_services () {
  audit_linux_logfiles
  audit_syslog_conf
  audit_debug_logging
  audit_syslog_auth
  audit_core_dumps
  audit_cron_logging
  audit_logrotate
}

audit_network_services () {
  audit_snmp
  audit_ntp
  audit_ipmi
  audit_echo
  audit_ocfserv 
  audit_tname
  audit_service_tags
  audit_ticotsord
  audit_boot_server
  audit_slp
  audit_tnd
  audit_nobody_rpc
}

# Update services

audit_update_services () {
  apply_latest_patches
  audit_yum_conf
}

# Other remaining services

audit_other_services () {
  audit_postgresql
  audit_encryption_kit
}

# Audit vitualisation services

audit_virtualisation_services () {
  audit_zones
  audit_xen
}

audit_system_all () {
  
  audit_shell_services
  audit_accounting_services
  audit_firewall_services
  audit_password_services
  audit_kernel_services
  audit_sendmail_services
  audit_user_services
  audit_disk_services
  audit_virtualisation_services
  audit_x11_services
  audit_naming_services
  audit_file_services
  audit_web_services
  audit_print_services
  audit_routing_services
  audit_windows_services
  audit_startup_services
  audit_log_services
  audit_network_services
  audit_other_services
  audit_update_services
}

audit_search_fs () {
  if [ "$os_name" = "SunOS" ]; then
    nb_check=`pkginfo -l |grep SYMCnbclt |grep PKG |awk '{print $2}'`
    if [ "$nb_check" != "SYMCnbclt" ]; then
      audit_bpcd
      audit_vnetd
      audit_vopied
      audit_bpjava_msvc
    else
      check_file="/etc/hosts.allow"
      audit_file_value $check_file bpcd colon " ALL" hash
      audit_file_value $check_file vnetd colon " ALL" hash
      audit_file_value $check_file bpcd vopied " ALL" hash
      audit_file_value $check_file bpcd bpjava-msvc " ALL" hash
    fi
    audit_extended_attributes
  fi
  audit_writable_files
  audit_suid_files
  audit_file_perms
  audit_sticky_bit
}

audit_system_x86 () {
  if [ "$os_name" = "SunOS" ]; then
    audit_grub_security
    audit_kdm_config
  fi
}

audit_system_sparc () {
  if [ "$os_name" = "SunOS" ]; then
    audit_eeprom_security
  fi
}

audit_test_subset () {
  audit_legacy
}

print_results () {
  echo ""
  if [ "$audit_mode" != 1 ]; then
    if [ "$reboot" = 1 ]; then
      reboot="Required"
    else
      reboot="Not Required"
    fi
    echo "Reboot:    $reboot"
  fi
  if [ "$audit_mode" = 1 ]; then
    echo "Tests:     $total"
    minus=`expr $score : -`
    if [ "$minus" = "1" ]; then
      score=`echo $score |sed 's/-//'`
	    score=`echo $total - $score |bc`
    fi
    echo "Score:     $score"
  fi
  if [ "$audit_mode" = 0 ]; then
    echo "Backup:    $work_dir"
    echo "Restore:   $0 -u $date_suffix"
  fi
  echo ""
}

audit_select () {
  audit_mode=$1
  function=$2
  check_environment
  $function
  print_results
}

audit_system () {
  audit_mode=$1
  check_environment
  if [ "$audit_mode" = 0 ]; then
    if [ ! -d "$work_dir" ]; then
      mkdir -p $work_dir
      if [ "$os_name" = "SunOS" ]; then
        echo "Creating:  Alternate Boot Environment $date_suffix"
        if [ "$os_version" = "11" ]; then
          beadm create audit_$date_suffix
        fi
        if [ "$os_version" = "8" ] || [ "$os_version" = "9" ] || [ "$os_version" = "10" ]; then
          if [ "$os_platform" != "i386" ]; then
            lucreate -n audit_$date_suffix
          fi
        fi
      else
        :
        # Add code to do LVM snapshot
      fi
    fi
  fi
  if [ "$audit_mode" = 2 ]; then
    restore_dir="$base_dir/$restore_date"
    if [ ! -d "$restore_dir" ]; then
      echo "Restore directory $restore_dir does not exit"
      exit
    else
      echo "Setting:   Restore directory to $restore_dir"
    fi
  fi
  audit_system_all
  if [ "$do_fs" = 1 ]; then
    audit_search_fs
  fi
  #audit_test_subset
  if [ `expr "$os_platform" : "sparc"` != 1 ]; then
    audit_system_x86
  else
    audit_system_sparc
  fi
  print_results
}

while getopts abdlps:u:hASVL args; do
  case $args in
    a)
      echo "Running:   In audit mode (no changes will be made to system)"
      echo "           Filesystem checks will not be done"
      audit_mode=1
      do_fs=0
      audit_system $audit_mode
      exit
      ;;
    s)
      echo "Running:   In audit mode (no changes will be made to system)"
      echo "           Filesystem checks will not be done"
      audit_mode=1
      do_fs=0
      function="$OPTARG"
      echo "Auditing:  Selecting $function"
      audit_select $audit_mode $function
      exit
      ;;
    S)
      echo ""
      echo "Functions:"
      cat $0 |grep 'audit_' |grep '()' | awk '{print $1}'
      ;;
    A)
      echo "Running:   In audit mode (no changes will be made to system)"
      echo "           Filesystem checks will be done"
      audit_mode=1
      do_fs=1
      audit_system $audit_mode
      exit
      ;;
    l)
      echo "Running:   In lockdown mode (changes will be made to system)"
      echo "           Filesystem checks will not be done"
      audit_mode=0
      do_fs=0
      audit_system $audit_mode
      exit
      ;;
    L)
      echo "Running:   In lockdown mode (no changes will be made to system)"
      echo "           Filesystem checks will be done"
      audit_mode=0
      do_fs=1
      audit_system $audit_mode
      exit
      ;;
    u)
      echo "Running:   In Restore mode (changes will be made to system)"
      audit_mode=2
      restore_date="$OPTARG"
      echo "Setting:   Restore date $restore_date"
      audit_system $audit_mode
      exit
      ;;
    h)
      print_usage
      exit
      ;;
    V)
      echo $script_version
      exit
      ;;
    p)
      echo "Printing previous settings:"
      print_previous
      exit
      ;;
    d)
      echo "Printing changes:"
      print_changes
      exit
      ;;
    b)
      echo "Previous backups:"
      ls $base_dir
      exit
      ;;
    *)
      print_usage
      exit
      ;;
  esac
done
